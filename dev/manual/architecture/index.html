<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Architecture · CryoGrid.jl</title><meta name="title" content="Architecture · CryoGrid.jl"/><meta property="og:title" content="Architecture · CryoGrid.jl"/><meta property="twitter:title" content="Architecture · CryoGrid.jl"/><meta name="description" content="Documentation for CryoGrid.jl."/><meta property="og:description" content="Documentation for CryoGrid.jl."/><meta property="twitter:description" content="Documentation for CryoGrid.jl."/><meta property="og:url" content="https://cryogrid.github.io/CryoGrid.jl/v0/manual/architecture/"/><meta property="twitter:url" content="https://cryogrid.github.io/CryoGrid.jl/v0/manual/architecture/"/><link rel="canonical" href="https://cryogrid.github.io/CryoGrid.jl/v0/manual/architecture/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CryoGrid.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../quickstart/">Getting Started</a></li><li><span class="tocitem">User manual</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>Architecture</a><ul class="internal"><li><a class="tocitem" href="#Modular-design"><span>Modular design</span></a></li><li><a class="tocitem" href="#Model-structure"><span>Model structure</span></a></li><li><a class="tocitem" href="#Control-flow"><span>Control flow</span></a></li><li><a class="tocitem" href="#State-variables"><span>State variables</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../coupling/">Coupling layers and processes</a></li></ul></li><li><span class="tocitem">Developer guide</span><ul><li><a class="tocitem" href="../../dev/concepts/">Concepts</a></li><li><a class="tocitem" href="../../dev/debugging/">Debugging</a></li><li><a class="tocitem" href="../../dev/contributing/">Contributing</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/heat_freeW_bucketW_samoylov/">Soil heat with bucket water scheme</a></li><li><a class="tocitem" href="../../examples/heat_freeW_lite_implicit/">Fast heat conduction with CryoGridLite</a></li><li><a class="tocitem" href="../../examples/heat_freeW_samoylov/">Soil heat with free water freeze curve</a></li><li><a class="tocitem" href="../../examples/heat_freeW_seb_snow_bucketW_samoylov/">Soil heat w/ SEB, snow cover, and bucket water scheme</a></li><li><a class="tocitem" href="../../examples/heat_freeW_snow_samoylov/">Soil heat with bulk snow scheme</a></li><li><a class="tocitem" href="../../examples/heat_sfcc_constantbc/">Soil heat with SFCC and constant BCs</a></li><li><a class="tocitem" href="../../examples/heat_sfcc_salt_constantbc/">Coupled heat and salt diffusion on salty soil column</a></li><li><a class="tocitem" href="../../examples/heat_sfcc_samoylov/">Soil heat with SFCC</a></li><li><a class="tocitem" href="../../examples/heat_simple_autodiff_grad/">Computing parameter sensitivities with autodiff</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/">Index</a></li><li><a class="tocitem" href="../../api/toplevel/">CryoGrid</a></li><li><a class="tocitem" href="../../api/numerics/">Numerics</a></li><li><a class="tocitem" href="../../api/utils/">Utilities</a></li><li><input class="collapse-toggle" id="menuitem-7-5" type="checkbox"/><label class="tocitem" for="menuitem-7-5"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/physics/heat_conduction/">Heat Conduction</a></li><li><a class="tocitem" href="../../api/physics/hydrology/">Hydrology</a></li><li><a class="tocitem" href="../../api/physics/soils/">Soils</a></li><li><a class="tocitem" href="../../api/physics/snow/">Snow</a></li><li><a class="tocitem" href="../../api/physics/seb/">Surface Energy Balance</a></li><li><a class="tocitem" href="../../api/physics/salt/">Salt</a></li></ul></li><li><a class="tocitem" href="../../api/tiles/">Tiles</a></li><li><input class="collapse-toggle" id="menuitem-7-7" type="checkbox"/><label class="tocitem" for="menuitem-7-7"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/solvers/basic_solvers/">Built-in</a></li><li><a class="tocitem" href="../../api/solvers/diffeq/">SciML/DiffEq</a></li><li><a class="tocitem" href="../../api/solvers/lite_implicit/">CryoGridLite</a></li></ul></li><li><a class="tocitem" href="../../api/diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../../api/presets/">Presets</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User manual</a></li><li class="is-active"><a href>Architecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Architecture</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CryoGrid/CryoGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CryoGrid/CryoGrid.jl/blob/master/docs/src/manual/architecture.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="arch"><a class="docs-heading-anchor" href="#arch">Architecture</a><a id="arch-1"></a><a class="docs-heading-anchor-permalink" href="#arch" title="Permalink"></a></h1><p>This page provides a general overview of the code organization and architecture of CryoGrid.jl.</p><h2 id="Modular-design"><a class="docs-heading-anchor" href="#Modular-design">Modular design</a><a id="Modular-design-1"></a><a class="docs-heading-anchor-permalink" href="#Modular-design" title="Permalink"></a></h2><p><a href="https://en.wikipedia.org/wiki/Modular_programming">Modular programming</a> in software design revolves around the separation of computer programs into &quot;modules&quot; that can be independently constructed, tested, and coupled together into a larger system. The benefits of modular programming are well documented and have been common practice in software engineering for decades [1]. In the context of physical modeling, modular programming has the potential to facilitate rapid prototyping and comparison of different model configurations, parameterizations, and process interactions [2].</p><p>The term &quot;modular programming&quot; is fairly abstract and encompasses a wide range of patterns and techniques centered around the central aim of building robust and reusable software components. <a href="https://en.wikipedia.org/wiki/Namespace">Namespaces</a> are a commonly employed tool for organizing code into standalone modules or packages that share functionality and naming patterns. Namespaces help avoid name collisions by localizing variable and function names to their enclosing namespace, therefore resolving possible ambiguities.</p><p>In Julia, namespaces are declared via <a href="https://docs.julialang.org/en/v1/manual/modules/">modules</a>. Modules are more-or-less self-contained namespaces which can be used to organize and isolate code. Modules can &quot;export&quot; methods or variables which are intended for external use via <code>export</code> statements. Other modules can then import these methods or variables into their namespace via <code>using</code> and <code>import</code> statements; e.g. <code>using Dates</code> brings all <code>export</code>ed names from the <code>Dates</code> module into the current namespace. Note that the top-level module (i.e. in a script or in the REPL) is always called <code>Main</code>.</p><p>The <code>CryoGrid</code> module provided by CryoGrid.jl is organized into a series of submodules:</p><table><tr><th style="text-align: right">Name</th><th style="text-align: right">Description</th><th style="text-align: right">Depends on</th></tr><tr><td style="text-align: right"><code>Utils</code></td><td style="text-align: right">Miscellaneous utility methods and types.</td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Numerics</code></td><td style="text-align: right">Utilities for math, array caches, and spatial discretization.</td><td style="text-align: right"><code>Utils</code></td></tr><tr><td style="text-align: right"><code>InputOutput</code></td><td style="text-align: right">Methods and types related to reading and writing input and output data.</td><td style="text-align: right"><code>Utils</code>,<code>Numerics</code></td></tr><tr><td style="text-align: right"><code>Diagnostics</code></td><td style="text-align: right">Tools for model diagnostics.</td><td style="text-align: right"><code>Utils</code>,<code>Numerics</code></td></tr><tr><td style="text-align: right"><code>Hydrology</code></td><td style="text-align: right">Methods and types for computing water related quanities.</td><td style="text-align: right"><code>Utils</code>,<code>Numerics</code></td></tr><tr><td style="text-align: right"><code>Heat</code></td><td style="text-align: right">Methods and types for computing heat and energy related quanities.</td><td style="text-align: right"><code>Utils</code>,<code>Numerics</code>,<code>Hydrology</code></td></tr><tr><td style="text-align: right"><code>Soils</code></td><td style="text-align: right">Defines <code>Soil</code> layers and provides dispatches for soil-specific physical processes.</td><td style="text-align: right"><code>Utils</code>,<code>Numerics</code>,<code>Hydrology</code>,<code>Heat</code></td></tr><tr><td style="text-align: right"><code>Snow</code></td><td style="text-align: right">Defines <code>Snowpack</code> layer and provides dispatches for snow processes.</td><td style="text-align: right"><code>Utils</code>,<code>Numerics</code>,<code>Hydrology</code>,<code>Heat</code></td></tr><tr><td style="text-align: right"><code>Salt</code></td><td style="text-align: right">Provides types and dispatches for coupled heat/salt diffusion in saline soils.</td><td style="text-align: right"><code>Utils</code>,<code>Numerics</code>,<code>Hydrology</code>,<code>Heat</code>,<code>Soils</code></td></tr><tr><td style="text-align: right"><code>Surface</code></td><td style="text-align: right">Defines boundary processes for the surface such as the surface energy and water balance equations.</td><td style="text-align: right"><code>Utils</code>,<code>Numerics</code>,<code>Hydrology</code>,<code>Heat</code>,<code>Soils</code>,<code>Snow</code></td></tr><tr><td style="text-align: right"><code>Tiles</code></td><td style="text-align: right">Defines the <code>Tile</code> and <code>Stratigraphy</code> types for constructing 1D land models.</td><td style="text-align: right"><code>Utils</code>,<code>Numerics</code>,<code>InputOutput</code></td></tr><tr><td style="text-align: right"><code>DiffEq</code></td><td style="text-align: right">Provides dispatches and utilities for integrating with solvers from the SciML <code>OrdinaryDiffEq</code> package.</td><td style="text-align: right"><code>Utils</code>,<code>Numerics</code>,<code>InputOutput</code></td></tr><tr><td style="text-align: right"><code>LiteImplicit</code></td><td style="text-align: right">Provides an implementation of the <code>CryoGridLite</code> solver scheme from Langer et al. 2023.</td><td style="text-align: right"><code>Utils</code>,<code>Numerics</code></td></tr><tr><td style="text-align: right"><code>Presets</code></td><td style="text-align: right">Provides pre-defined stratigraphies, forcings, and layer configurations to facilitate rapid prototyping.</td><td style="text-align: right"><code>Utils</code>,<code>Numerics</code>,<code>InputOutput</code>,<code>Heat</code>,<code>Hydrology</code>,<code>Soils</code></td></tr></table><p>Note that all submodules depend on the top-level <code>CryoGrid</code> module which declares all of the &quot;core&quot; types and <a href="https://docs.julialang.org/en/v1/manual/interfaces/">method interfaces</a> for defining model behavior. Each submodule may additionally define its own method interfaces related to its own specific process(es) or layer(s).</p><p>The <code>@reexport</code> macro from the <code>Reexport</code> package is used extensively to propagate exported methods and types to the top-level <code>CryoGrid</code> namespace. This is intended to alleviate the user of the burden to keep track of which types/methods are exported by which submodules. In most cases, it is sufficient to simply <code>import</code> or <code>using</code> the <code>CryoGrid</code> module in order to bring all CryoGrid-related methods and types into scope.</p><h2 id="Model-structure"><a class="docs-heading-anchor" href="#Model-structure">Model structure</a><a id="Model-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Model-structure" title="Permalink"></a></h2><p>In the context of CryoGrid, a &quot;model&quot; typically refers to one or more <a href="../../api/tiles/#CryoGrid.Tiles.Tile"><code>Tile</code></a>s [2] which may or may not be laterally coupled together. A <code>Tile</code> typically corresponds to a rectangular volume discretized along the vertical z-axis, i.e. corresponding physically to depth/elevation. CryoGrid.jl implements this concept by defining a single <code>Tile</code> as a composition of the following:</p><ul><li>A <a href="../../api/tiles/#CryoGrid.Tiles.Stratigraphy"><code>Stratigraphy</code></a> with three or more <a href="../../api/toplevel/#CryoGrid.Layer"><code>Layer</code></a>s, including a <a href="../../api/toplevel/#CryoGrid.Top"><code>Top</code></a> layer and a <a href="../../api/toplevel/#CryoGrid.Bottom"><code>Bottom</code></a> layer.</li><li>A <a href="@ref"><code>StateVars</code></a> cache which stores all non-prognostic state and grid data.</li><li>Zero or more <a href="../../api/toplevel/#CryoGrid.VarInitializer"><code>VarInitializer</code></a>s that define the intial condition of the prognostic state.</li><li>Zero or more layer <a href="@ref"><code>Event</code></a>s that may or may not be invoked when their trigger conditions are met.</li></ul><p>The <code>Stratigraphy</code> is simply a <code>Tuple</code> of layers in ascending order of depth (i.e. top to bottom) paired with (initial) upper boundary depths. The thickness of each stratigraphy layer is therefore determined by the distance between the upper boundary of the layer and the upper boundary of the following layer. Depending on the configuration of the layer, this thickness may be either static or dynamic over time. In the latter case, the layer thickness <code>Δz</code> is automatically included as a prognostic state variable.</p><p>Each <code>SubSurface</code> layer in the stratigraphy will typically consist of one or more <code>Process</code>es as fields on the layer <code>struct</code> which should then be explicitly declared via a dispatch of the <a href="../../api/toplevel/#CryoGrid.processes-Tuple{Layer}"><code>processes</code></a> method. The <a href="../../api/toplevel/#CryoGrid.variables-Tuple{Layer, Process}"><code>variables</code></a> and <a href="@ref"><code>events</code></a> methods similarly declare state variables and events respectively that should be defined for any given configuration of the layer.</p><p>The <code>Tile</code> constructor collects all of the relevant state variables declared by <code>variables</code> and discretizes them according to the given <a href="../../api/numerics/#CryoGrid.Numerics.DiscretizationStrategy"><code>DiscretizationStrategy</code></a>. The resulting state vectors are initialized in the forward-diff compatible <a href="@ref"><code>StateVars</code></a> cache. On each invocation of <code>Tile</code>, the current <a href="../../api/tiles/#CryoGrid.Tiles.TileState"><code>TileState</code></a> is constructed from the current prognostic state variable <code>u</code>, parameter vector <code>p</code>, and time step <code>t</code>. The <code>TileState</code> consists of named <a href="@ref"><code>LayerState</code></a>s which provide layer-local <code>view</code>s of each state variable array, i.e. only grid cells within the layer boundaries are included.</p><h2 id="Control-flow"><a class="docs-heading-anchor" href="#Control-flow">Control flow</a><a id="Control-flow-1"></a><a class="docs-heading-anchor-permalink" href="#Control-flow" title="Permalink"></a></h2><p>The <code>CryoGrid</code> module defines three primary methods that can be used to implement the behavior of each <code>Layer</code>/<code>Process</code> in any given model configuration. When updating the model at a particular timestep, these methods are typically invoked in the following order:</p><ol><li><a href="../../api/toplevel/#CryoGrid.computediagnostic!-Tuple{Layer, Any}"><code>computediagnostic!</code></a> updates all (non-flux) state variables and/or derived quantities based on the current (prognostic) state.</li><li><a href="../../api/toplevel/#CryoGrid.interact!-Tuple{Layer, Layer, Any, Any}"><code>interact!</code></a> defines interactions between adjacent layers in the stratigraphy, including fluxes over the layer boundary.</li><li><a href="../../api/toplevel/#CryoGrid.computefluxes!-Tuple{Layer, Any}"><code>computefluxes!</code></a> computes all internal fluxes (and the divergence thereof) within each layer, after boundary fluxes are taken into account by <code>interact!</code>.</li></ol><p>Layer and/or process specific implementations of each of these methods can generally assume that the previous methods have already been invoked by the caller (it is the responsibility of the calling code to ensure that this is the case). This is, for example, the order in which these methods will be invoked by <code>tile(du, u, p t)</code>.</p><p>Note that, due to the nature of multiple dispatch, the execution path (i.e. with respect to the actual source code) of any given model configuration will typically be quite nonlinear and may span multiple source files depending on where the matching method dispatches are defined. Users may find the <code>which</code> provided by Julia (and correspondingly the <code>@which</code> macro from <code>InteractiveUtils</code>) useful in figuring out where executing code is located. For example:</p><pre><code class="language-julia hljs">using CryoGrid
using CryoGrid.Diagnostics

soil = Ground()
grid = CryoGrid.Presets.DefaultGrid_5cm
state = Diagnostics.build_dummy_state(grid, soil)

@which CryoGrid.computediagnostic!(soil, state)</code></pre><p>Output:</p><pre><code class="nohighlight hljs">computediagnostic!(layer::Layer, state)
     @ CryoGrid ~/workspace/sparc-local/repos/CryoGrid/CryoGrid.jl/src/methods.jl:55</code></pre><h2 id="State-variables"><a class="docs-heading-anchor" href="#State-variables">State variables</a><a id="State-variables-1"></a><a class="docs-heading-anchor-permalink" href="#State-variables" title="Permalink"></a></h2><p>In order to facilitate modularity and ease-of-use, CryoGrid.jl provides an automated system for initializing and configuring state variables for any given model configuration. Note that there is an important distinction between two types of model state: <strong>prognostic</strong> and <strong>diagnostic</strong>.</p><p><code>Prognostic</code>(@ref) state variables fully define the state of the system at any given time <code>t</code>. They form what is typically called the &quot;phase space&quot; or &quot;state space&quot; in the mathematics and engineering literature. In order to be compatible with standard ODE solvers (e.g. like those in <code>OrdinaryDiffEq</code>), CryoGrid.jl automatically assembles prognostic state variables into a single array <code>u</code> (and its corresponding time derivative <code>du</code>) which is returned when initializing a <code>Tile</code> with the <code>initialcondition!</code> method. Note again that this array should always fully define the state of the system.</p><p><code>Diagnostic</code>(@ref) state variables act as caches for intermediate and derived quantities defined by the model. They also may, in some cases, provide a means of coupling between different processes (e.g. the heat and water flux variables <code>jH</code> and <code>jw</code> might be updated by more than one <code>Process</code>). For any model configuration, all diagnostic variables should be fully updated (and thus consistent) with the given prognostic state after invoking <code>computediagnostic!</code>, <code>interact!</code>, and <code>computefluxes!</code>.</p><p>When a <code>Tile</code> is constructed, all variables defined by each layer in the <code>Stratigraphy</code> are collected and then intiailized in <a href="@ref"><code>StateVars</code></a> according to the given <code>DiscretizationStrategy</code>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] Bass L, Clements P, Kazman R. Software architecture in practice. Addison-Wesley Professional; 2003.</p><p>[2] Westermann S, Ingeman-Nielsen T, Scheer J, Aalstad K, Aga J, Chaudhary N, Etzelmüller B, Filhol S, Kääb A, Renette C, Schmidt LS. The CryoGrid community model (version 1.0)–a multi-physics toolbox for climate-driven simulations in the terrestrial cryosphere. Geoscientific Model Development. 2023 May 15;16(9):2607-47.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../coupling/">Coupling layers and processes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 15 February 2024 00:06">Thursday 15 February 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
