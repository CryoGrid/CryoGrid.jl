var documenterSearchIndex = {"docs":
[{"location":"api/presets/","page":"Presets","title":"Presets","text":"Modules = [CryoGrid.Models]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"CryoGrid.jl can be installed via the Julia package manager:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add https://gitlab.awi.de/sparcs/cryogrid/cryogridjulia","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"or equivalently in code/REPL:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.add([\"https://gitlab.awi.de/sparcs/cryogrid/cryogridjulia\"])","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Be aware that CryoGrid.jl is a relatively large package with quite a few dependencies, so installation into a blank Julia environment could take several minutes.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"It is recommended that you work with CryoGrid.jl as a Julia package rather than cloning the repository and hacking on it directly. This will allow for more rapid development and minimize latency from precompile time. It is also recommended to create a dedicated Julia environment in your workspace to better manage package dependencies. This can be accomplished by running:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"activate .","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"in your working directory, or by starting Julia with the --project=. option. Then, you can proceed to install CryoGrid.jl into the environment via the commands above.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can load CryoGrid.jl in your Julia REPL or editor by running:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using CryoGrid","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"or similarly:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"import CryoGrid","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The latter option will bring only the CryoGrid module name into scope rather than all of its exported components.","category":"page"},{"location":"api/seb/#Surface-Energy-Balance","page":"Surface Energy Balance","title":"Surface Energy Balance","text":"","category":"section"},{"location":"api/seb/","page":"Surface Energy Balance","title":"Surface Energy Balance","text":"Modules = [CryoGrid.SEB]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/seb/#CryoGrid.Physics.SEB.SurfaceEnergyBalance-Tuple{Top, Soil, Heat, Any, Any}","page":"Surface Energy Balance","title":"CryoGrid.Physics.SEB.SurfaceEnergyBalance","text":"Top interaction, ground heat flux from surface energy balance. (no snow, no water body, no infiltration)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Modules = [CryoGrid.Utils]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/utils/#CryoGrid.Utils.Params","page":"Utilities","title":"CryoGrid.Utils.Params","text":"Base type for composite parameter types. Permits iteration of struct fields.\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#CryoGrid.Utils.applyunit-Tuple{Unitful.Units, Number}","page":"Utilities","title":"CryoGrid.Utils.applyunit","text":"applyunit(u::Unitful.Units, x::Number)\n\nConditionally applies unit u to x if and only if x is a unit-free quantity. If x is a unitful quantity, asserts that the unit matches u.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.convert_tspan-Tuple{Tuple{DateTime, DateTime}}","page":"Utilities","title":"CryoGrid.Utils.convert_tspan","text":"convert_tspan(tspan::Tuple{DateTime,DateTime})\nconvert_tspan(tspan::Tuple{Float64,Float64})\n\nConvenience method for converting between Dates.DateTime and solver time.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.dustrip-Tuple{Number}","page":"Utilities","title":"CryoGrid.Utils.dustrip","text":"Debug ustrip. Remove units if and only if debug mode is NOT enabled.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.structiterate-Tuple{A} where A","page":"Utilities","title":"CryoGrid.Utils.structiterate","text":"Provides implementation of Base.iterate for structs.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.@Float_str-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@Float_str","text":"Similar to @UT_str but produces a Float64 quantity type for the given unit if and only if debug mode is enabled. If debug mode is not enabled, plain Float64 is used instead.\n\n\n\n\n\n","category":"macro"},{"location":"api/utils/#CryoGrid.Utils.@Number_str-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@Number_str","text":"Similar to @UT_str but produces a Float64 quantity type for the given unit if and only if debug mode is enabled. If debug mode is not enabled, plain Number is used instead.\n\n\n\n\n\n","category":"macro"},{"location":"api/utils/#CryoGrid.Utils.@Real_str-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@Real_str","text":"Similar to @UT_str but produces a Float64 quantity type for the given unit if and only if debug mode is enabled. If debug mode is not enabled, plain Real is used instead.\n\n\n\n\n\n","category":"macro"},{"location":"api/utils/#CryoGrid.Utils.@UFloat_str-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@UFloat_str","text":"Similar to Unitful.@u_str (i.e. u\"kg\") but produces the type of the quantity rather than the instance. NOT conditional on debug mode.\n\n\n\n\n\n","category":"macro"},{"location":"api/utils/#CryoGrid.Utils.@UT_str-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@UT_str","text":"Similar to Unitful.@u_str (i.e. u\"kg\") but produces the type of the unit rather than the instance. NOT conditional on debug mode.\n\n\n\n\n\n","category":"macro"},{"location":"api/utils/#CryoGrid.Utils.@setscalar-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@setscalar","text":"Convenience macro for setting scalar (single-element) arrays/vectors. It turns an expression of the form:     a.b = ... into     a.b[1] = ...\n\nThis is primarily intended for code clarity, i.e to clearly discern scalar and non-scalar values.\n\n\n\n\n\n","category":"macro"},{"location":"api/utils/#CryoGrid.Utils.@threaded-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@threaded","text":"Prepends expr with Threads.@threads if and only if Threads.nthreads() > 1, thus avoiding the overhead of @threads when running in single-threaded mode.\n\nCredit to @ranocha (Hendrik Ranocha) https://discourse.julialang.org/t/overhead-of-threads-threads/53964/22\n\n\n\n\n\n","category":"macro"},{"location":"api/utils/#CryoGrid.Utils.@xu_str-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@xu_str","text":"Similar to Unitful.@u_str (i.e. u\"kg\") but conditional on debug mode being enabled. Otherwise, no unit is applied. This should be used to apply units (and thus dimensional analysis checks) to physical quantities at test time but not during normal execution to avoid unnecessary overhead.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Index-of-public-API","page":"Index","title":"Index of public API","text":"","category":"section"},{"location":"api/","page":"Index","title":"Index","text":"","category":"page"},{"location":"api/toplevel/#toplevel","page":"Method interface","title":"Top level methods and types","text":"","category":"section"},{"location":"api/toplevel/","page":"Method interface","title":"Method interface","text":"Modules = [CryoGrid]\nPrivate = false\nOrder = [:type, :constant, :function, :macro]","category":"page"},{"location":"api/toplevel/#CryoGrid.Bottom","page":"Method interface","title":"CryoGrid.Bottom","text":"Bottom <: Layer\n\nGeneric \"bottom\" layer that marks the lower boundary of the subsurface grid.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.BoundaryProcess","page":"Method interface","title":"CryoGrid.BoundaryProcess","text":"BoundaryProcess\n\nAbstract base type for boundary processes, i.e. processes that operate at the boundaries of the subsurface. A BoundaryProcess represents the boundary conditions of one or more SubSurfaceProcesses but may include its own diagnostic (or even prognostic) variables, if necessary.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.BoundaryStyle","page":"Method interface","title":"CryoGrid.BoundaryStyle","text":"Trait that specifies the \"style\" or kind of boundary condition. This can be used to write generic implementations of interact! that are (relatively) agnostic to specific implementations of BoundaryProcess. A good example of this can be found in the boundaryflux method interface.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.BoundaryStyle-Union{Tuple{Type{BP}}, Tuple{BP}} where BP<:BoundaryProcess","page":"Method interface","title":"CryoGrid.BoundaryStyle","text":"BoundaryStyle(::Type{T})\n\nCan be overriden by BoundaryProcess types to indicate the type of boundary condition, e.g:\n\nBoundaryStyle(::Type{BP}) = Dirichlet()\n\nwhere BP is a BoundaryProcess that provides the boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.Callback","page":"Method interface","title":"CryoGrid.Callback","text":"Callback\n\nBase type for callback implementations.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.CallbackStyle","page":"Method interface","title":"CryoGrid.CallbackStyle","text":"CallbackStyle\n\nTrait for callback types.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.CallbackStyle-Tuple{C} where C<:Callback","page":"Method interface","title":"CryoGrid.CallbackStyle","text":"CallbackStyle(::C)\nCallbackStyle(::Type{<:Callback})\n\nTrait implementation that defines the \"style\" or type of the given callback as any subtype of CallbackStyle, for example Discrete or Continuous.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.Coupled","page":"Method interface","title":"CryoGrid.Coupled","text":"Coupled{P1,P2} = CoupledProcesses{Tuple{T1,T2}} where {T1,T2}\n\nRepresents an explicitly coupled pair processes. Alias for CoupledProcesses{Tuple{P1,P2}}. Coupled provides a simple mechanism for defining new behaviors on multi-processes systems.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.Coupled-Union{Tuple{P2}, Tuple{P1}, Tuple{P1, P2}} where {P1<:Process, P2<:Process}","page":"Method interface","title":"CryoGrid.Coupled","text":"Coupled(p1,p2)\n\nAlias for CoupledProcesses(p1,p2).\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.CoupledProcesses","page":"Method interface","title":"CryoGrid.CoupledProcesses","text":"CoupledProcesses{TProcs} <: Process\n\nRepresents an explicitly or implicitly coupled system of processes. TProcs is always a Tuple of other processes.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.Dirichlet","page":"Method interface","title":"CryoGrid.Dirichlet","text":"BoundaryStyle instance for Dirichlet boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.Layer","page":"Method interface","title":"CryoGrid.Layer","text":"Abstract base type for all layers.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.Neumann","page":"Method interface","title":"CryoGrid.Neumann","text":"BoundaryStyle instance for Neumann boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.Process","page":"Method interface","title":"CryoGrid.Process","text":"Abstract base type for all dynamical processes.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.SubSurface","page":"Method interface","title":"CryoGrid.SubSurface","text":"SubSurface <: Layer\n\nAbstract base type for layers in the stratigraphy, e.g. soil, snow, pond, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.SubSurfaceProcess","page":"Method interface","title":"CryoGrid.SubSurfaceProcess","text":"SubSurfaceProcess <: Process\n\nAbstract base type for subsurface processes, i.e. processes that operate at or below the surface, such as heat conduction, water infiltration, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.Top","page":"Method interface","title":"CryoGrid.Top","text":"Top <: Layer\n\nGeneric \"top\" layer that marks the upper boundary of the subsurface grid.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.affect!-Tuple{Callback, Layer, Process, Any}","page":"Method interface","title":"CryoGrid.affect!","text":"affect!(c::Callback, ::Layer, ::Process, state)\n\nCallback action executed when criterion is met (boolean condition for discrete callbacks, zero for continuous callbacks).\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.boundaryflux-Tuple{BoundaryProcess, Union{Bottom, Top}, SubSurfaceProcess, SubSurface, Any, Any}","page":"Method interface","title":"CryoGrid.boundaryflux","text":"boundaryflux(bc::BoundaryProcess, b::Union{Top,Bottom}, p::SubSurfaceProcess, sub::SubSurface, s1, s2)\nboundaryflux(s::BoundaryStyle, bc::BoundaryProcess, b::Union{Top,Bottom}, p::SubSurfaceProcess, sub::SubSurface, s1, s2)\n\nComputes the flux dH/dt at the boundary layer. Calls boundaryflux(BoundaryStyle(B),...) to allow for generic implementations by boundary condition type.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.boundaryvalue-Tuple{BoundaryProcess, Any, Any, Any, Any, Any}","page":"Method interface","title":"CryoGrid.boundaryvalue","text":"boundaryvalue(bc::BoundaryProcess, b, p, layer, sbc, ssub)\n\nComputes the value of the boundary condition specified by bc for the given layer/process combinations.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.criterion-Tuple{Callback, Layer, Process, Any}","page":"Method interface","title":"CryoGrid.criterion","text":"criterion(c::Callback, ::Layer, ::Process, state)\n\nCallback criterion/condition. Should return a Bool for discrete callbacks and a real number for continuous callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.diagnosticstep!-Tuple{Layer, Process, Any}","page":"Method interface","title":"CryoGrid.diagnosticstep!","text":"diagnosticstep!(l::Layer, p::Process, state)\n\nDefines the diagnostic update for a Process on a given Layer.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.initialcondition!-Tuple{Layer, Any}","page":"Method interface","title":"CryoGrid.initialcondition!","text":"initialcondition!(::Layer, state)\ninitialcondition!(::Process, state) = nothing\ninitialcondition!(::Layer, ::Process, state)\n\nDefines the initial condition for a given Process and/or Layer. initialcondition! should write initial values into all relevant state variables in state.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.initialcondition!-Tuple{Layer, Process, Layer, Process, Any, Any}","page":"Method interface","title":"CryoGrid.initialcondition!","text":"initialcondition!(::Layer, ::Process, ::Layer, ::Process, state1, state2)\n\nDefines the initial condition for two processes on adjacent layers. initialcondition! should write initial values into all relevant state variables in state.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.interact!-Tuple{Layer, Process, Layer, Process, Any, Any}","page":"Method interface","title":"CryoGrid.interact!","text":"interact!(::Layer, ::Process, ::Layer, ::Process, state1, state2)\n\nDefines a boundary interaction between two processes on adjacent layers. For any interaction, the order of the arguments follows decreasing depth, i.e. the first layer/process is always on top of the second layer/process. This ordering matters and separate dispatches must be provided for interactions in reverse order.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.observe-Union{Tuple{name}, Tuple{Val{name}, Layer, Process, Any}} where name","page":"Method interface","title":"CryoGrid.observe","text":"observe(::Val{name}, ::Layer, ::Process, state1)\n\nCalled at the end of each step. Can be used by the user to add additional observables via @log without affecting the model implementation. As such, this function should not be used in implementations, but only by users and code which monitors/consumes CryoGrid model outputs.\n\nExample:\n\nobserve(::Val{:meanT}, ::SubSurface, ::Heat, state) = @log meanT = mean(state.T)\n# build model\n...\nsetup = Tile(stratigraphy, grid, observed=[:meanT])\n# solve\n...\n# retrieve results\n@show out.log.meanT # will be a DimArray of meanT at each timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.prognosticstep!-Tuple{Layer, Process, Any}","page":"Method interface","title":"CryoGrid.prognosticstep!","text":"prognosticstep!(l::Layer, p::Process, state)\n\nDefines the prognostic update for a Process on a given layer. Note that an instance of prognosticstep! must be provided for all non-boundary (subsurface) processes/layers.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.variables-Tuple{Layer}","page":"Method interface","title":"CryoGrid.variables","text":"variables(::Layer)\nvariables(::Process)\nvariables(layer::Layer, process::Process)\n\nDefines variables for a given Process and/or Layer. Implementations should return a Tuple of Vars.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#Numerics","page":"Numerics","title":"Numerics","text":"","category":"section"},{"location":"api/numerics/","page":"Numerics","title":"Numerics","text":"DocTestSetup = quote\n    using CryoGrid\nend","category":"page"},{"location":"api/numerics/","page":"Numerics","title":"Numerics","text":"Modules = [CryoGrid.Numerics]\nPrivate = true\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/numerics/#CryoGrid.Numerics.ConstantInit","page":"Numerics","title":"CryoGrid.Numerics.ConstantInit","text":"ConstantInit{varname,T} <: VarInit\n\nInitializes a scalar or vector-valued state variable with a pre-specified constant value.\n\n\n\n\n\n","category":"type"},{"location":"api/numerics/#CryoGrid.Numerics.DiffCache","page":"Numerics","title":"CryoGrid.Numerics.DiffCache","text":"DiffCache{N,A,Adual}\n\nExtension of PreallocationTools.DiffCache that stores state variables in forward-diff compatible cache arrays.\n\n\n\n\n\n","category":"type"},{"location":"api/numerics/#CryoGrid.Numerics.Grid","page":"Numerics","title":"CryoGrid.Numerics.Grid","text":"struct Grid{S,G,Q,A} <: AbstractDiscretization{Q,1}\n\nRepresents the 1D spatial discretization on which time integration is performed. S is a GridSpec, either Edges or Cells (always edges upon initial construction). The grid representation can be converted (allocation free) between grid edges and cells via the cells and edges methods. G represents the geometry/volume on which the vertical 1D discretization is applied. A is the underlying array type, and Q is the numerical type (e.g. Float64 or a Unitful.Quantity).\n\n\n\n\n\n","category":"type"},{"location":"api/numerics/#CryoGrid.Numerics.InterpInit","page":"Numerics","title":"CryoGrid.Numerics.InterpInit","text":"InterpInit{varname,P,I,E} <: VarInit\n\nInit for on-grid variables that takes a Profile as initial values and interpolates along the model grid. The interpolation mode is linear by default, but can also be quadratic, cubic, or any other Gridded interpolation mode supported by Interpolations.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/numerics/#CryoGrid.Numerics.VarStates","page":"Numerics","title":"CryoGrid.Numerics.VarStates","text":"VarStates{names,griddvars,TU,TD,TV,DF,DG}\n\nGeneric container for holding discretized state arrays for declared variables (Var types), as well as the prototype prognostic state vector (uproto).\n\n\n\n\n\n","category":"type"},{"location":"api/numerics/#CryoGrid.Numerics.VarStates-Union{Tuple{A}, Tuple{NamedTuple{names, var\"#s73\"} where {names, var\"#s73\"<:Tuple{Vararg{Tuple{Vararg{Var, N} where N}, N} where N}}, CryoGrid.Numerics.AbstractDiscretization, Int64}, Tuple{NamedTuple{names, var\"#s73\"} where {names, var\"#s73\"<:Tuple{Vararg{Tuple{Vararg{Var, N} where N}, N} where N}}, CryoGrid.Numerics.AbstractDiscretization, Int64, Type{A}}} where A<:(AbstractVector{T} where T)","page":"Numerics","title":"CryoGrid.Numerics.VarStates","text":"VarStates(vars::GroupedVars, D::Numerics.AbstractDiscretization, chunksize::Int, arrayproto::Type{A}=Vector) where {A<:AbstractVector}\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.discretize-Union{Tuple{A}, Tuple{D}, Tuple{N}, Tuple{T}, Tuple{Q}, Tuple{Type{A}, D, Var}} where {Q, T, N, D<:CryoGrid.Numerics.AbstractDiscretization{Q, N}, A<:AbstractArray{T, N}}","page":"Numerics","title":"CryoGrid.Numerics.discretize","text":"discretize([::Type{A}], ::T,  ::Var) where {T,N,D<:AbstractDiscretization{T,N},A<:AbstractArray{T,N}}\n\nProduces a discretization of the given variable based on T and array type A.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.finitediff!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T}","page":"Numerics","title":"CryoGrid.Numerics.finitediff!","text":"finitediff!(∂x::AbstractVector, x::AbstractVector, Δ::AbstractVector)\n\nFirst order forward finite difference operator.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.harmonicmean!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T}","page":"Numerics","title":"CryoGrid.Numerics.harmonicmean!","text":"harmonicmean!(h::AbstractVector, x::AbstractVector, w::AbstractVector)\n\nVectorized harmonic mean of elements in x with weights w. Output is stored in h, which should have size length(x)-1.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.harmonicmean-NTuple{4, Any}","page":"Numerics","title":"CryoGrid.Numerics.harmonicmean","text":"harmonicmean(x₁, x₂, w₁, w₂)\n\nSimple weighted harmonic mean of two values, x₁ and x₂.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.heaviside-Tuple{Any}","page":"Numerics","title":"CryoGrid.Numerics.heaviside","text":"heaviside(x)\n\nDifferentiable implementation of heaviside step function, i.e:\n\nh(x) = begincases 1  x  0  0  x  0 endcases\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.init!-Tuple{AbstractVector{T} where T, CryoGrid.Numerics.VarInit, Vararg{Any, N} where N}","page":"Numerics","title":"CryoGrid.Numerics.init!","text":"init!(x::AbstractVector, init::VarInit, args...)\n\nInitializes state variable x using initializer init and implementation-specific additional arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.initializer-Union{Tuple{T}, Tuple{Symbol, T}} where T","page":"Numerics","title":"CryoGrid.Numerics.initializer","text":"initializer(varname::Symbol, value::T) where {T} => ConstantInit\ninitializer(varname::Symbol, profile::Profile, interp=Linear(), extrap=Flat()) => InterpInit\n\nConvenience constructor for VarInits that selects the appropriate initializer type based on the arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.lineardiffusion!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, Number}","page":"Numerics","title":"CryoGrid.Numerics.lineardiffusion!","text":"lineardiffusion!(∂y::AbstractVector, x::AbstractVector, Δ::AbstractVector, k::Number)\n\nSecond order Laplacian with constant diffusion k.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.logistic-Tuple{Any}","page":"Numerics","title":"CryoGrid.Numerics.logistic","text":"logistic(x)\n\nNumerically stable logistic function.\n\nσ(x) = begincases frac11+exp(-x)  x  0  fracexp(x)1+exp(x)  x  0 endcases\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.logit-Tuple{Any}","page":"Numerics","title":"CryoGrid.Numerics.logit","text":"logit(x)\n\nNumerically stable logit function. True domain is (0,1) but inputs are clamped to (ϵ,1-ϵ) for numerical convenience, making the effective domain (-∞,∞).\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.nonlineardiffusion!-NTuple{5, AbstractVector{T} where T}","page":"Numerics","title":"CryoGrid.Numerics.nonlineardiffusion!","text":"nonlineardiffusion!(\n    ∂y::AbstractVector{Float64},\n    x::AbstractVector{Float64}, \n    Δx::AbstractVector{Float64},\n    k::AbstractVector{Float64},\n    Δk::AbstractVector{Float64}\n)\n\nSecond order Laplacian with non-linear diffusion operator, k. Accelerated using LoopVectorization.@turbo for Float64 vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.profile2array-Union{Tuple{Profile{N, D, T}}, Tuple{T}, Tuple{D}, Tuple{N}, Tuple{M}} where {M, N, D, T}","page":"Numerics","title":"CryoGrid.Numerics.profile2array","text":"profile2array(profile::Profile{N,D,T};names) where {N,D,T}\n\nConstructs a DimArray from the given Profile, i.e. pairs Q => (x1,...,xn) where x1...xn are the values defined at Q. Column names for the resulting DimArray can be set via the names parameter which accepts an NTuple of symbols, where N must match the number of parameters given (i.e. n).\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.softplus-Tuple{Any}","page":"Numerics","title":"CryoGrid.Numerics.softplus","text":"softplus(x)\n\nNumerically stable softplus function.\n\ns(x) = log(1+exp(-x)) + max(xϵ)\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.softplusinv-Tuple{Any}","page":"Numerics","title":"CryoGrid.Numerics.softplusinv","text":"softplusinv(x)\n\nNumerically stable softplus inverse function. True domain is (0,∞) but inputs are clamped to (ϵ,∞) for numerical convenience, making the effective domain (-∞,∞).\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.∇-Tuple{Any, Symbol}","page":"Numerics","title":"CryoGrid.Numerics.∇","text":"∇(f, dvar::Symbol)\n\nAutomatically generates an analytical partial derivative of f w.r.t dvar using Symbolics.jl. To avoid symbolic tracing issues, the function should 1) be pure (no side effects or non-mathematical behavior) and 2) avoid indeterminate control flow such as if-else or while blocks (technically should work but sometimes doesn't...). Conditional logic can be included using IfElse.ifelse. Additional argument names are extracted automatically from the method signature of f. Keyword arg choosefn should be a function which selects from available methods of f (returned by methods); defaults to first. Note that ∇ uses RuntimeGeneratedFunction to produce a fully specialized and compiled Julia function; it may be slow on the first call (due to compilation), but should be just as fast as handwriting it on subsequent calls.\n\nExample:\n\nFor f(xy) = 2x + xy, fracpartial fpartial x = 2 + y. Using ∇, we can obtain this automagically:\n\nf(x,y) = 2*x + x*y\n∇f_x = ∇(f,:x)\n∇f_x(2.0,3.0)\n\n# output\n\n5.0\n\n\n\n\n\n","category":"method"},{"location":"api/strat/#Strat","page":"Stratigraphy","title":"Strat","text":"","category":"section"},{"location":"api/strat/","page":"Stratigraphy","title":"Stratigraphy","text":"This module contains the Stratigraphy, Tile, and related types for building and evaluating a CryoGrid 1-D process model.","category":"page"},{"location":"api/strat/","page":"Stratigraphy","title":"Stratigraphy","text":"Modules = [Strat]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/strat/#CryoGrid.Strat.LayerState","page":"Stratigraphy","title":"CryoGrid.Strat.LayerState","text":"LayerState{iip,TStates,TGrids,Tt,Tz,varnames}\n\nRepresents the state of a single component (layer + processes) in the stratigraphy.\n\n\n\n\n\n","category":"type"},{"location":"api/strat/#CryoGrid.Strat.StratComponent","page":"Stratigraphy","title":"CryoGrid.Strat.StratComponent","text":"StratComponent{TLayer,TProcess,name}\n\nRepresents a single component (layer + processes) in the stratigraphy.\n\n\n\n\n\n","category":"type"},{"location":"api/strat/#CryoGrid.Strat.Stratigraphy","page":"Stratigraphy","title":"CryoGrid.Strat.Stratigraphy","text":"Stratigraphy{N,TComponents,Q}\n\nDefines a 1-dimensional stratigraphy by connecting a top and bottom layer to 1 or more subsurface layers.\n\n\n\n\n\n","category":"type"},{"location":"api/strat/#CryoGrid.Strat.Tile","page":"Stratigraphy","title":"CryoGrid.Strat.Tile","text":"Tile{TStrat,TGrid,TStates,iip,obsv} <: AbstractTile{iip}\n\nDefines the full specification of a single CryoGrid tile; i.e. stratigraphy, grid, and state variables.\n\n\n\n\n\n","category":"type"},{"location":"api/strat/#CryoGrid.Strat.Tile-Union{Tuple{A}, Tuple{Stratigraphy, Grid{Edges, var\"#s65\", var\"#s64\", A} where {var\"#s65\"<:CryoGrid.Numerics.Geometry, var\"#s64\"<:(Quantity{T, 𝐋, U} where {T, U<:(Unitful.FreeUnits{N, 𝐋, nothing} where N)}), A}}} where A<:AbstractArray","page":"Stratigraphy","title":"CryoGrid.Strat.Tile","text":"Constructs a Tile from the given stratigraphy and grid. arrayproto keyword arg should be an array instance (of any arbitrary length, including zero, contents are ignored) that will determine the array type used for all state vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/strat/#CryoGrid.Strat.TileState","page":"Stratigraphy","title":"CryoGrid.Strat.TileState","text":"TileState{iip,TGrid,TStates,Tt,names}\n\nRepresents the instantaneous state of a CryoGrid Tile.\n\n\n\n\n\n","category":"type"},{"location":"api/strat/#CryoGrid.Strat.componentname-Union{Tuple{StratComponent{L, P, name}}, Tuple{name}, Tuple{P}, Tuple{L}} where {L, P, name}","page":"Stratigraphy","title":"CryoGrid.Strat.componentname","text":"Get the name of the given stratigraphy node.\n\n\n\n\n\n","category":"method"},{"location":"api/strat/#CryoGrid.Strat.getstate-Tuple{Symbol, Tile, Any, Any, Any}","page":"Stratigraphy","title":"CryoGrid.Strat.getstate","text":"getstate(layername::Symbol, tile::Tile, u, du, t)\ngetstate(::Val{layername}, tile::Tile{TStrat,TGrid,<:VarStates{layernames},iip}, _u, _du, t)\n\nConstructs a LayerState representing the full state of layername given tile, state vectors u and du, and the time step t.\n\n\n\n\n\n","category":"method"},{"location":"api/strat/#CryoGrid.Strat.getstate-Union{Tuple{iip}, Tuple{TStates}, Tuple{TGrid}, Tuple{TStrat}, Tuple{Tile{TStrat, TGrid, TStates, iip, obsv} where obsv, Any, Any, Any}} where {TStrat, TGrid, TStates, iip}","page":"Stratigraphy","title":"CryoGrid.Strat.getstate","text":"Gets the \n\n\n\n\n\n","category":"method"},{"location":"api/strat/#CryoGrid.Strat.withaxes-Tuple{AbstractArray, Tile}","page":"Stratigraphy","title":"CryoGrid.Strat.withaxes","text":"withaxes(u::AbstractArray, ::Tile)\n\nConstructs a ComponentArray with labeled axes from the given state vector u. Assumes u to be of the same type/shape as setup.uproto.\n\n\n\n\n\n","category":"method"},{"location":"api/strat/#CryoGrid.Strat.@Stratigraphy-Tuple","page":"Stratigraphy","title":"CryoGrid.Strat.@Stratigraphy","text":"Convenience macro for defining stratigraphies with multiple subsurface layers.\n\n\n\n\n\n","category":"macro"},{"location":"api/boundaries/#Boundary-conditions-and-forcings","page":"Boundary conditions and forcings","title":"Boundary conditions and forcings","text":"","category":"section"},{"location":"api/boundaries/","page":"Boundary conditions and forcings","title":"Boundary conditions and forcings","text":"Modules = [Boundaries]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/boundaries/#CryoGrid.Physics.Boundaries.Constant","page":"Boundary conditions and forcings","title":"CryoGrid.Physics.Boundaries.Constant","text":"struct Constant{S,T} <: BoundaryProcess\n\nConstant boundary condition (of any type/unit) specified by value.\n\n\n\n\n\n","category":"type"},{"location":"api/boundaries/#CryoGrid.Physics.Boundaries.Damping","page":"Boundary conditions and forcings","title":"CryoGrid.Physics.Boundaries.Damping","text":"Damping{D,K} <: BoundaryEffect\n\nGeneric implementation of bulk conductive damping at the boundary.\n\n\n\n\n\n","category":"type"},{"location":"api/boundaries/#CryoGrid.Physics.Boundaries.Forcing","page":"Boundary conditions and forcings","title":"CryoGrid.Physics.Boundaries.Forcing","text":"  Forcing{T,N}\n\nAbstract type representing a generic external boundary condition (i.e. \"forcing\").\n\n\n\n\n\n","category":"type"},{"location":"api/boundaries/#CryoGrid.Physics.Boundaries.Periodic","page":"Boundary conditions and forcings","title":"CryoGrid.Physics.Boundaries.Periodic","text":"struct Periodic{S,T} <: BoundaryProcess\n\nPeriodic boundary condition (of any type/unit) specified by period, amplitude, and phaseshift.\n\n\n\n\n\n","category":"type"},{"location":"api/boundaries/#CryoGrid.Physics.Boundaries.TimeSeriesForcing","page":"Boundary conditions and forcings","title":"CryoGrid.Physics.Boundaries.TimeSeriesForcing","text":"  TimeSeriesForcing{T,A,I}\n\nForcing provided by a discrete time series of data.\n\n\n\n\n\n","category":"type"},{"location":"api/boundaries/#CryoGrid.Physics.Boundaries.TimeSeriesForcing-Tuple{Number}","page":"Boundary conditions and forcings","title":"CryoGrid.Physics.Boundaries.TimeSeriesForcing","text":"Get interpolated forcing value at t seconds from t0.\n\n\n\n\n\n","category":"method"},{"location":"manual/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"manual/overview/#Setting-up-a-model","page":"Overview","title":"Setting up a model","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"At the highest level, a model in CryoGrid.jl is defined by a Grid and a Stratigraphy, constructed top-down from individual StratComponents, each of which consists of a Layer and one or more Processes. Each node in the Stratigraphy is assigned a depth, which then aligns it with the Grid. All models must consist of at least three layers/nodes: Top and Bottom layers with corresponding boundary conditions, as well as one or more SubSurface layers. Here we define a simple three-layer model (or one-layer, exlcuding the boundaries) with a single sub-surface process, i.e. Heat (heat conduction):","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"# ... load forcings, set up profiles, etc.\n# see examples/heat_vgfc_seb_saoylov_custom.jl for more details\nstrat = Stratigraphy(\n    -2.0u\"m\" => top(SurfaceEnergyBalance(Tair,pr,q,wind,Lin,Sin,z)),\n    0.0u\"m\" => subsurface(:soil, Soil(soilprofile), Heat(:H;freezecurve=SFCC(DallAmico()))),\n    1000.0u\"m\" => bottom(GeothermalHeatFlux(0.053u\"J/s/m^2\"))\n);\ngrid = CryoGrid.Presets.DefaultGrid_5cm\ntile = Tile(strat,grid);","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"This model can then be used to construct an ODEProblem (from DiffEqBase.jl) via the CryoGridProblem constructor:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"tspan = (DateTime(2010,10,30),DateTime(2011,10,30))\np = parameters(tile)\n# define initial conditions for temperature using a given profile;\n# The default initializer linearly interpolates between profile points.\ninitT = initializer(:T, tempprofile)\nu0 = initialcondition!(tile, tspan, p, initT)\nprob = CryoGridProblem(tile, u0, tspan, p, savevars=(:T,)) # produces an ODEProblem with problem type CryoGridODEProblem","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"It can then be solved simply using the solve function (also from DiffEqBase and OrdinaryDiffEq):","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"# solve with forward Euler (fixed 5 minute time steps) and construct CryoGridOutput from solution\nout = @time solve(prob, Euler(), dt=5*60.0, saveat=24*3600.0, progress=true) |> CryoGridOutput;","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"The result is a CryoGridOutput type which provides DimArrays containing the model outputs over time and space:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"julia> out.T\n278×366 DimArray{Float64,2} with dimensions: \n  Z: Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}[0.01 m, 0.03 m, …, 850.0 m, 950.0 m] Sampled: Ordered Irregular Points,\n  Ti (Time): DateTime[2010-10-30T00:00:00, …, 2011-10-30T00:00:00] Sampled: Ordered Irregular Points","category":"page"},{"location":"manual/overview/#Defining-model-behavior","page":"Overview","title":"Defining model behavior","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Notice that, in the example above, it is types such as Soil, Heat, SFCC, etc. that specify which components the model should use. These components are defined by adding method dispatches to the core model API methods. State variables are declared via the variables method, e.g:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"\"\"\" Variable definitions for heat conduction (enthalpy) on soil layer. \"\"\"\nvariables(soil::Soil, heat::Heat{:H}) = (\n    Prognostic(:H, Float\"J/m^3\", OnGrid(Cells)),\n    Diagnostic(:T, Float\"°C\", OnGrid(Cells)),\n    Diagnostic(:C, Float\"J//K*/m^3\", OnGrid(Cells)),\n    Diagnostic(:Ceff, Float\"J/K/m^3\", OnGrid(Cells)),\n    Diagnostic(:k, Float\"W/m/K\", OnGrid(Edges)),\n    Diagnostic(:kc, Float\"W//m/K\", OnGrid(Cells)),\n    # this last line just appends any state variables or parameters\n    # defined by the freeze curve to the tuple.\n    variables(soil, heat, freezecurve(heat))...,\n)","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"When the Heat process is assigned to a Soil layer, Tile will invoke this method and create state variables corresponding to each Var. Prognostic variables are assigned derivatives (in this case, dH, since H is the prognostic state variable) and integrated over time. Diagnostic variables provide in-place caches for intermediary variables/computations and can be automatically tracked by the modeling engine.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Each variable definition consists of a name (a Julia Symbol), a type, and a shape. For variables discretized on the grid, the shape is specified by OnGrid, which will generate an array of the appropriate size when the model is compiled. The arguments Cells and Edges specify whether the variable should be defined on the grid cells or edges respecitvely.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"The real work finally happens in diagnosticstep! and prognosticstep!, the latter of which should be used to compute the time derivatives (here dH). interact! defines the behavior at the boundaries and should be used to compute the derivatives (and any other necessary values) at the interface between layers.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"We can take as an example the implementation of prognosticstep! for enthalpy-based heat conduction:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"\"\"\" Prognostic step for heat conduction (enthalpy) on soil layer. \"\"\"\nfunction prognosticstep!(::Soil, ::Heat{:H}, state)\n    Δk = Δ(state.grids.k) # cell sizes\n    ΔT = Δ(state.grids.T)\n    # Diffusion on non-boundary cells\n    heatconduction!(state.dH,state.T,ΔT,state.k,Δk)\nend","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nPrognostic state variables like H in the example above should not be directly modified in user code. This is especially important when using higher order or implicit integrators as unexpected changes to the underlying state may destroy the accuracy of their internal interpolators. For modleing discontinuities, use Callbacks instead.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Note that state is of type LayerState with fields corresponding to the variables declared by the variables function for Soil and Heat. Additionally, output arrays for the time derivatives are provided (here dH), as well as the current timestep, layer boundary depths, and variable grids (accessible via state.t, state.bounds, and state.grids respectively). Note that state will also contain other variables declared on this Soil layer by other SubSurfaceProcesses, allowing for implicit coupling between processes where appropriate.","category":"page"},{"location":"api/heat_conduction/#Heat-conduction","page":"Heat Conduction","title":"Heat conduction","text":"","category":"section"},{"location":"api/heat_conduction/","page":"Heat Conduction","title":"Heat Conduction","text":"Modules = [HeatConduction]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/heat_conduction/#CryoGrid.Physics.HeatConduction.DallAmico","page":"Heat Conduction","title":"CryoGrid.Physics.HeatConduction.DallAmico","text":"DallAmico <: SFCCFunction\n\nDall'Amico M, 2010. Coupled water and heat transfer in permafrost modeling. Ph.D. Thesis, University of Trento, pp. 43.\n\n\n\n\n\n","category":"type"},{"location":"api/heat_conduction/#CryoGrid.Physics.HeatConduction.FreeWater-Tuple{SubSurface, Heat{FreeWater, CryoGrid.Physics.HeatConduction.Enthalpy}, Any}","page":"Heat Conduction","title":"CryoGrid.Physics.HeatConduction.FreeWater","text":"Implementation of \"free water\" freeze curve for any subsurface layer. Assumes that 'state' contains at least temperature (T), enthalpy (H), heat capacity (C), total water content (θw), and liquid water content (θl).\n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.HeatConduction.McKenzie","page":"Heat Conduction","title":"CryoGrid.Physics.HeatConduction.McKenzie","text":"McKenzie <: SFCCFunction\n\nMcKenzie JM, Voss CI, Siegel DI, 2007. Groundwater flow with energy transport and water-ice phase change:     numerical simulations, benchmarks, and application to freezing in peat bogs. Advances in Water Resources,     30(4): 966–983. DOI: 10.1016/j.advwatres.2006.08.008.\n\n\n\n\n\n","category":"type"},{"location":"api/heat_conduction/#CryoGrid.Physics.HeatConduction.SFCC","page":"Heat Conduction","title":"CryoGrid.Physics.HeatConduction.SFCC","text":"SFCC{F,∇F,S} <: FreezeCurve\n\nGeneric representation of the soil freeze characteristic curve. The shape and parameters of the curve are determined by the implementation of SFCCFunction f. Also requires an implementation of SFCCSolver which provides the solution to the non-linear mapping H <–> T.\n\n\n\n\n\n","category":"type"},{"location":"api/heat_conduction/#CryoGrid.Physics.HeatConduction.SFCC-2","page":"Heat Conduction","title":"CryoGrid.Physics.HeatConduction.SFCC","text":"SFCC(f::SFCCFunction, s::SFCCSolver=SFCCNewtonSolver())\n\nConvenience constructor for SFCC that automatically generates an analytical derivative of the given freeze curve function f using ModelingToolkit/Symbolics.jl. To avoid symbolic tracing issues, the function should 1) be pure (no side effects or non-mathematical behavior) and 2) avoid indeterminate control flow such as if-else or while blocks (technically should work but sometimes doesn't...). Conditional logic can be incorporated via IfElse.ifelse. See the documentation for Symbolics.jl for more information and technical details.\n\n\n\n\n\n","category":"type"},{"location":"api/heat_conduction/#CryoGrid.Physics.HeatConduction.SFCC-Tuple{Soil, Heat{var\"#s101\", CryoGrid.Physics.HeatConduction.Enthalpy} where var\"#s101\"<:SFCC, Any}","page":"Heat Conduction","title":"CryoGrid.Physics.HeatConduction.SFCC","text":"Updates state variables according to the specified SFCC function and solver. For heat conduction with enthalpy, this is implemented as a simple passthrough to the non-linear solver. For heat conduction with temperature, we can simply evaluate the freeze curve to get C_eff, θl, and H.\n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.HeatConduction.SFCCNewtonSolver","page":"Heat Conduction","title":"CryoGrid.Physics.HeatConduction.SFCCNewtonSolver","text":"Specialized implementation of Newton's method with backtracking line search for resolving the energy conservation law, H = TC + Lθ. Attempts to find the root of the corresponding temperature residual: ϵ = T - (H - Lθ(T)) / C(θ(T)) and uses backtracking to avoid jumping over the solution. This prevents convergence issues that arise due to discontinuities and non-monotonic behavior in most common soil freeze curves.\n\n\n\n\n\n","category":"type"},{"location":"api/heat_conduction/#CryoGrid.Physics.HeatConduction.Westermann","page":"Heat Conduction","title":"CryoGrid.Physics.HeatConduction.Westermann","text":"Westermann <: SFCCFunction\n\nWestermann, S., Boike, J., Langer, M., Schuler, T. V., and Etzelmüller, B.: Modeling the impact of     wintertime rain events on the thermal regime of permafrost, The Cryosphere, 5, 945–959,     https://doi.org/10.5194/tc-5-945-2011, 2011. \n\n\n\n\n\n","category":"type"},{"location":"api/heat_conduction/#CryoGrid.Physics.HeatConduction.heatcapacity!-Tuple{Soil, Heat, Any}","page":"Heat Conduction","title":"CryoGrid.Physics.HeatConduction.heatcapacity!","text":"Heat capacity for soil layer \n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.HeatConduction.heatconduction!-NTuple{5, Any}","page":"Heat Conduction","title":"CryoGrid.Physics.HeatConduction.heatconduction!","text":"heatconduction!(∂H,T,ΔT,k,Δk)\n\n1-D heat conduction/diffusion given T, k, and their deltas. Resulting enthalpy gradient is stored in ∂H. Note that this function does not perform bounds checking. It is up to the user to ensure that all variables are arrays of the correct length.\n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.HeatConduction.thermalconductivity!-Tuple{Soil, Heat, Any}","page":"Heat Conduction","title":"CryoGrid.Physics.HeatConduction.thermalconductivity!","text":"Thermal conductivity for soil layer \n\n\n\n\n\n","category":"method"},{"location":"quickstart/#Quick-start","page":"Getting Started","title":"Quick start","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"After installing CryoGrid.jl, you can get started right away with a simple soil heat model. The Presets module (aliased CryoGrid.Presets) provides pre-specified model configurations that can be obtained with a single function call. It is also possible to modify the soil and initial temperature profiles via SoilLayerConfig; here SamoylovDefault is used.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Single layer heat conduction model with free water freeze curve and air temperature upper boundary condition:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"using CryoGrid\nusing Plots\n\n# load provided forcing data from Samoylov;\n# The forcing file will be automatically downloaded to the input/ folder if not already present.\nforcings = loadforcings(CryoGrid.Presets.Forcings.Samoylov_ERA_obs_fitted_1979_2014_spinup_extended_2044, :Tair => u\"°C\");\n# use air temperature as upper boundary forcing\ntair = TimeSeriesForcing(ustrip.(forcings.data.Tair), forcings.timestamps, :Tair);\n# get preset soil and initial temperature profile for Samoylov\nsoilprofile, tempprofile = CryoGrid.Presets.SamoylovDefault\n# basic 1-layer heat conduction model (defaults to free water freezing scheme)\nmodel = CryoGrid.Presets.SoilHeatColumn(TemperatureGradient(tair), soilprofile)\n# define time span (1 year)\ntspan = (DateTime(2010,10,30),DateTime(2011,10,30))\np = parameters(model)\ninitT = initializer(:T, tempprofile)\nu0 = initialcondition!(model, tspan, p, initT)\n# CryoGrid front-end for ODEProblem\nprob = CryoGridProblem(model,u0,tspan,p,savevars=(:T,))\n# solve discretized system, saving every 6 hours;\n# Trapezoid on a discretized PDE is analogous to the well known Crank-Nicolson method.\nout = @time solve(prob, Trapezoid(), saveat=6*3600.0, progress=true) |> CryoGridOutput;\nzs = [1.0,5,10,20,30,50,100,500,1000]u\"cm\"\ncg = Plots.cgrad(:copper,rev=true)\nplot(out.T[Z(Near(zs))], color=cg[LinRange(0.0,1.0,length(zs))]', ylabel=\"Temperature\", leg=false)","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"(Image: Ts_output_freew)","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Alternatively, we can use a Dall'Amico freeze curve:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"model = CryoGrid.Presets.SoilHeatColumn(TemperatureGradient(tair), soilprofile, freezecurve=SFCC(DallAmico()))\n# Set-up parameters\np = parameters(model)\ntspan = (DateTime(2010,10,30),DateTime(2011,10,30))\n# CryoGrid front-end for ODEProblem\nprob = CryoGridProblem(model,u0,tspan,p,savevars=(:T,))\n# stiff solvers don't work well with Dall'Amico due to the ill-conditioned Jacobian;\n# We can just forward Euler instead.\nout = @time solve(prob, Euler(), dt=120.0, saveat=6*3600.0, progress=true) |> CryoGridOutput;\nplot(out.T[Z(Near(zs))], color=cg[LinRange(0.0,1.0,length(zs))]', ylabel=\"Temperature\", leg=false)","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Note that SoilHeat uses energy as the state variable by default. To use temperature as the state variable instead:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"# :T is the variable name for temperature, :H represents enthalpy/energy.\n# This is used in the specification of the Heat process type.\n# While this will work with any freeze curve, here we use Westermann (2011) as an example.\nmodel = CryoGrid.Presets.SoilHeatColumn(:T, TemperatureGradient(tair), soilprofile, freezecurve=SFCC(Westermann()))","category":"page"},{"location":"api/diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"api/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Modules = [Diagnostics]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.active_layer_thickness-Tuple{DimensionalData.AbstractDimArray{var\"#s268\", N, D, A} where {var\"#s268\"<:(Quantity{T, 𝚯, U} where {T, U<:(Unitful.FreeUnits{N, 𝚯, A} where {N, A})}), N, D<:Tuple, A}}","page":"Diagnostics","title":"CryoGrid.Diagnostics.active_layer_thickness","text":"active_layer_thickness(T::AbstractDimArray{<:TempQuantity})\n\nComputes active layer thickness annually. The active layer thickness is defined here as the maximum thaw depth throughout the calendar year. Assumes T to have dimensions Ti (time) and Z (depth) in any order.\n\n\n\n\n\n","category":"method"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.mean_annual_ground_temperature-Tuple{DimensionalData.AbstractDimArray{var\"#s100\", N, D, A} where {var\"#s100\"<:(Quantity{T, 𝚯, U} where {T, U<:(Unitful.FreeUnits{N, 𝚯, A} where {N, A})}), N, D<:Tuple, A}}","page":"Diagnostics","title":"CryoGrid.Diagnostics.mean_annual_ground_temperature","text":"mean_annual_ground_temperature(T::AbstractDimArray; upper_limit=0u\"m\", lower_limit=10u\"m\")\n\nComputes mean annual ground temperature between upper_limit and lower_limit. Assumes T to have dimensions Ti (time) and Z (depth) in any order.\n\n\n\n\n\n","category":"method"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.permafrostbase-Tuple{DimensionalData.AbstractDimArray{var\"#s268\", N, D, A} where {var\"#s268\"<:(Quantity{T, 𝚯, U} where {T, U<:(Unitful.FreeUnits{N, 𝚯, A} where {N, A})}), N, D<:Tuple, A}}","page":"Diagnostics","title":"CryoGrid.Diagnostics.permafrostbase","text":"permafrostbase(T::AbstractDimArray{<:TempQuantity})\n\nComputes depth of permafrost base for all years, i.e. the closest depth to the \"bottom\" at which the maximum annual temperature is strictly < 0°C. Assumes T to have dimensions Ti (time) and Z (depth) in any order.\n\n\n\n\n\n","category":"method"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.permafrosttable-Tuple{DimensionalData.AbstractDimArray{var\"#s268\", N, D, A} where {var\"#s268\"<:(Quantity{T, 𝚯, U} where {T, U<:(Unitful.FreeUnits{N, 𝚯, A} where {N, A})}), N, D<:Tuple, A}}","page":"Diagnostics","title":"CryoGrid.Diagnostics.permafrosttable","text":"permafrosttable(T::AbstractDimArray{<:TempQuantity})\n\nComputes depth of permafrost table for all years, i.e. the closest depth to the surface at which the maximum annual temperature is strictly < 0°C. Assumes T to have dimensions Ti (time) and Z (depth) in any order.\n\n\n\n\n\n","category":"method"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.spinup-Tuple{Tile, Tuple{DateTime, DateTime}, Any, Any, Any}","page":"Diagnostics","title":"CryoGrid.Diagnostics.spinup","text":"spinup(setup::Tile, tspan::NTuple{2,DateTime}, p, tol, layername; kwargs...)\n\nImplements a simple, iterative spin-up procedure. Runs the model specified by setup over tspan until the profile mean up to maxdepth over the whole time span changes only within the given tolerance tol. Returns the ODESolution generated by the final iteration.\n\n\n\n\n\n","category":"method"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.thawdepth-Tuple{DimensionalData.AbstractDimArray{var\"#s268\", N, D, A} where {var\"#s268\"<:(Quantity{T, 𝚯, U} where {T, U<:(Unitful.FreeUnits{N, 𝚯, A} where {N, A})}), N, D<:Tuple, A}}","page":"Diagnostics","title":"CryoGrid.Diagnostics.thawdepth","text":"thawdepth(T::AbstractDimArray{<:TempQuantity})\n\nComputes thaw depth (a.k.a freezing front) at all time steps. Assumes T to have dimensions Ti (time) and Z (depth) in any order.\n\n\n\n\n\n","category":"method"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.zero_annual_amplitude-Tuple{DimensionalData.AbstractDimArray{var\"#s100\", N, D, A} where {var\"#s100\"<:(Quantity{T, 𝚯, U} where {T, U<:(Unitful.FreeUnits{N, 𝚯, A} where {N, A})}), N, D<:Tuple, A}}","page":"Diagnostics","title":"CryoGrid.Diagnostics.zero_annual_amplitude","text":"zero_annual_amplitude(T::AbstractDimArray{<:TempQuantity}; threshold=0.5u\"°C\")\n\nComputes annual depth of zero amplitude (where |max - min| < threshold) and returns the result for each year. Assumes T to have dimensions Ti (time) and Z (depth) in any order.\n\n\n\n\n\n","category":"method"},{"location":"#CryoGrid.jl","page":"Home","title":"CryoGrid.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CryoGrid.jl is a Julia implementation of the CryoGrid land surface model using DifferentialEquations.jl and the SciML package ecosystem. Its primary goal is to provide a fast, flexible, and feature rich framework for modeling permafrost in Julia while simultaneously laying the groundwork for rapid prototyping of data-driven parameter estimation, uncertainty quantification, and causal analysis of complex Arctic land surface processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is part of the broader research project: Quantifying and explaining uncertainty in permafrost modeling under a warming climate","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\",\"installation.md\",\"quickstart.md\",\"manual/overview.md\",\"api/index.md\"]","category":"page"}]
}
