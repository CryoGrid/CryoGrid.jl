var documenterSearchIndex = {"docs":
[{"location":"api/presets/","page":"Presets","title":"Presets","text":"Modules = [CryoGrid.Models]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"CryoGrid.jl can be installed via the Julia package manager:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add https://gitlab.awi.de/sparcs/cryogrid/cryogridjulia","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"or equivalently in code/REPL:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.add([\"https://gitlab.awi.de/sparcs/cryogrid/cryogridjulia\"])","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Be aware that CryoGrid.jl is a relatively large package with quite a few dependencies, so installation into a blank Julia environment could take several minutes.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"It is recommended that you work with CryoGrid.jl as a Julia package rather than cloning the repository and hacking on it directly. This will allow for more rapid development and minimize latency from precompile time. It is also recommended to create a dedicated Julia environment in your workspace to better manage package dependencies. This can be accomplished by running:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"activate .","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"in your working directory, or by starting Julia with the --project=. option. Then, you can proceed to install CryoGrid.jl into the environment via the commands above.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can load CryoGrid.jl in your Julia REPL or editor by running:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using CryoGrid","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"or similarly:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"import CryoGrid","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The latter option will bring only the CryoGrid module name into scope rather than all of its exported components.","category":"page"},{"location":"api/seb/#Surface-Energy-Balance","page":"Surface Energy Balance","title":"Surface Energy Balance","text":"","category":"section"},{"location":"api/seb/","page":"Surface Energy Balance","title":"Surface Energy Balance","text":"Modules = [CryoGrid.SEB]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/seb/#CryoGrid.Physics.SEB.Analytical","page":"Surface Energy Balance","title":"CryoGrid.Physics.SEB.Analytical","text":"Byun 1990\n\n\n\n\n\n","category":"type"},{"location":"api/seb/#CryoGrid.Physics.SEB.Businger","page":"Surface Energy Balance","title":"CryoGrid.Physics.SEB.Businger","text":"Businger 1971\n\n\n\n\n\n","category":"type"},{"location":"api/seb/#CryoGrid.Physics.SEB.H√∏gstr√∏mSHEBA","page":"Surface Energy Balance","title":"CryoGrid.Physics.SEB.H√∏gstr√∏mSHEBA","text":"H√∏gstr√∏m 1988 (unstable conditions) SHEBA, Uttal et al., 2002, Grachev et al. 2007 (stable conditions)\n\n\n\n\n\n","category":"type"},{"location":"api/seb/#CryoGrid.Physics.SEB.Iterative","page":"Surface Energy Balance","title":"CryoGrid.Physics.SEB.Iterative","text":"Westermann2016, use info from last time step\n\n\n\n\n\n","category":"type"},{"location":"api/seb/#CryoGrid.Physics.SEB.Numerical","page":"Surface Energy Balance","title":"CryoGrid.Physics.SEB.Numerical","text":"equation by Westermann2016, but use Newton solver\n\nnot implemented yet\n\n\n\n\n\n","category":"type"},{"location":"api/seb/#CryoGrid.Physics.SEB.SurfaceEnergyBalance","page":"Surface Energy Balance","title":"CryoGrid.Physics.SEB.SurfaceEnergyBalance","text":"SurfaceEnergyBalance{TSolution,TStabFun,TPara,F} <: BoundaryProcess{HeatBalance}\n\nSurface energy balance upper boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"api/soils/#Soils","page":"Soils","title":"Soils","text":"","category":"section"},{"location":"api/soils/","page":"Soils","title":"Soils","text":"Modules = [Soils]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/soils/#CryoGrid.Physics.Soils.HomogeneousMixture","page":"Soils","title":"CryoGrid.Physics.Soils.HomogeneousMixture","text":"HomogeneousMixture{Tpor,Tsat,Torg} <: SoilParameterization\n\nRepresents a simple, uniform organic/mineral soil mixutre in terms of its characteristic fractions: i.e. natural porosity, saturation, organic solid fraction, and excess ice fraction.\n\n\n\n\n\n","category":"type"},{"location":"api/soils/#CryoGrid.Physics.Soils.Soil","page":"Soils","title":"CryoGrid.Physics.Soils.Soil","text":"Soil{Tpara<:SoilParameterization,Tprop,Tsp,Tproc} <: SubSurface{Tproc}\n\nGeneric Soil layer.\n\n\n\n\n\n","category":"type"},{"location":"api/soils/#CryoGrid.Physics.Soils.Soil-Tuple{Process}","page":"Soils","title":"CryoGrid.Physics.Soils.Soil","text":"Soil(\n    proc::Process;\n    para::SoilParameterization=HomogeneousMixture(),\n    prop::SoilProperties=SoilProperties(para, proc),\n    sp=nothing,\n)\n\nConstructs a Soil layer with the given process(es) proc, parameterization para, and soil properties prop.\n\n\n\n\n\n","category":"method"},{"location":"api/soils/#CryoGrid.Physics.Soils.SoilParameterization","page":"Soils","title":"CryoGrid.Physics.Soils.SoilParameterization","text":"SoilParameterization\n\nBase type for parameterizations of soil consituents.\n\n\n\n\n\n","category":"type"},{"location":"api/soils/#CryoGrid.Physics.Soils.SoilProperties","page":"Soils","title":"CryoGrid.Physics.Soils.SoilProperties","text":"Generic container for numerical constants related to soil processes.\n\n\n\n\n\n","category":"type"},{"location":"api/soils/#CryoGrid.Physics.Soils.SoilProperties-Tuple{SoilParameterization, Process}","page":"Soils","title":"CryoGrid.Physics.Soils.SoilProperties","text":"SoilProperties(para::SoilParameterization, proc::Process)\n\nConstructor for SoilProperties based on the given parameterization and process. This method should have dispatches added for each process or coupled processes that require additional properties to be defined.\n\n\n\n\n\n","category":"method"},{"location":"api/soils/#CryoGrid.Physics.Soils.SoilProfile-Tuple{Vararg{Pair{var\"#s118\", var\"#s117\"} where {var\"#s118\"<:(Quantity{T, ùêã, U} where {T, U<:(Unitful.FreeUnits{N, ùêã, nothing} where N)}), var\"#s117\"<:SoilParameterization}, N} where N}","page":"Soils","title":"CryoGrid.Physics.Soils.SoilProfile","text":"SoilProfile(pairs::Pair{<:DistQuantity,<:SoilParameterization}...)\n\nAlias for Profile(pairs...) assigning soil parameterizations to specific depths.\n\n\n\n\n\n","category":"method"},{"location":"api/soils/#CryoGrid.Physics.Soils.mineral-Tuple{Soil, Any, Any}","page":"Soils","title":"CryoGrid.Physics.Soils.mineral","text":"mineral(soil::Soil, state, i)\n\nRetrieves the mineral content for the given layer at grid cell i, if provided. Defaults to using the scalar mineral content defined on soil.\n\n\n\n\n\n","category":"method"},{"location":"api/soils/#CryoGrid.Physics.Soils.organic-Tuple{Soil, Any, Any}","page":"Soils","title":"CryoGrid.Physics.Soils.organic","text":"organic(soil::Soil, state, i)\n\nRetrieves the organic content for the given layer at grid cell i, if provided. Defaults to using the scalar organic content defined on soil.\n\n\n\n\n\n","category":"method"},{"location":"api/soils/#CryoGrid.Physics.Soils.porosity-Tuple{Soil, Any, Any}","page":"Soils","title":"CryoGrid.Physics.Soils.porosity","text":"porosity(soil::Soil, state, i)\n\nRetrieves the porosity for the given layer at grid cell i, if provided. Defaults to using the scalar porosity defined on soil.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Modules = [CryoGrid.Utils]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/utils/#CryoGrid.Utils.Named","page":"Utilities","title":"CryoGrid.Utils.Named","text":"Named{name,T}\n\nWraps a value of type T with a name type parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#CryoGrid.Utils.NamedTupleWrapper","page":"Utilities","title":"CryoGrid.Utils.NamedTupleWrapper","text":"NamedTupleWrapper\n\nBase type for container types that hold a NamedTuple of arbitrary field values. NamedTupleWrapper provides dispatches for getproperty and propertynames that forward property name queries to the NamedTuple container. Subtypes are by default assumed to have a field named values that corresponds to the NamedTuple container, but this can be overriden by providing a dispatch for Base.values.\n\n\n\n\n\n","category":"type"},{"location":"api/utils/#CryoGrid.Utils.applyunits-Tuple{Unitful.Units, Number}","page":"Utilities","title":"CryoGrid.Utils.applyunits","text":"applyunits(u::Unitful.Units, x::Number)\n\nConditionally applies unit u to x if and only if x is a unit-free quantity. If x is a unitful quantity, asserts that the unit matches u.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.convert_t-Tuple{DateTime}","page":"Utilities","title":"CryoGrid.Utils.convert_t","text":"convert_t(t::DateTime)\nconvert_t(t::Float64)\n\nConvenience method for converting between Dates.DateTime and solver time.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.convert_tspan-Tuple{Tuple{DateTime, DateTime}}","page":"Utilities","title":"CryoGrid.Utils.convert_tspan","text":"convert_tspan(tspan::Tuple{DateTime,DateTime})\nconvert_tspan(tspan::Tuple{Float64,Float64})\n\nConvenience method for converting between Dates.DateTime and solver time.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.duconvert-Tuple{Unitful.Units, Number}","page":"Utilities","title":"CryoGrid.Utils.duconvert","text":"Debug uconvert.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.dustrip-Tuple{Number}","page":"Utilities","title":"CryoGrid.Utils.dustrip","text":"Debug ustrip. Remove units if and only if debug mode is NOT enabled.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.fastiterate-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Tuple{Vararg{Any, N}}, N1} where N1}} where {F, N}","page":"Utilities","title":"CryoGrid.Utils.fastiterate","text":"fastiterate(f!::F, iters::NTuple{N,Any}...) where {F,N}\n\nSame as fastmap but simply invokes f! on each argument set without constructing a tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.fastmap-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{Tuple{Vararg{Any, N}}, N1} where N1}} where {F, N}","page":"Utilities","title":"CryoGrid.Utils.fastmap","text":"fastmap(f::F, iter::NTuple{N,Any}...) where {F,N}\n\nSame as map for NTuples but with guaranteed type stability. fastmap is a @generated function which unrolls calls to f into a loop-free tuple construction expression.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.getscalar-Tuple{Number}","page":"Utilities","title":"CryoGrid.Utils.getscalar","text":"getscalar(x)\ngetscalar(x, i)\n\nHelper method for generalizing between arrays and scalars. Without an index, retrieves the first element of x if x is an array, otherwise simply returning x. If an index i, is specified, returns the ith value of x if x is an array, or x otherwise. Note that this method is not strictly necessary since Julia allows for scalar quantities to be accessed at the first index like an array; however, the point is to make it expliclty clear in scalar-typed code that a state variable is treated as such and is not a vector valued quantity.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.pstrip-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.pstrip","text":"pstrip(obj; keep_units=false)\n\nStrips Param types and units from obj. If keep_units=true, then Param types will be stripped but units preserved.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.tuplejoin-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.tuplejoin","text":"tuplejoin([x, y], z...)\n\nConcatenates one or more tuples together; should generally be type stable.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#CryoGrid.Utils.@UFloat_str-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@UFloat_str","text":"Similar to Unitful.@u_str (i.e. u\"kg\") but produces the type of the quantity rather than the instance. NOT conditional on debug mode.\n\n\n\n\n\n","category":"macro"},{"location":"api/utils/#CryoGrid.Utils.@UT_str-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@UT_str","text":"Similar to Unitful.@u_str (i.e. u\"kg\") but produces the type of the unit rather than the instance. NOT conditional on debug mode.\n\n\n\n\n\n","category":"macro"},{"location":"api/utils/#CryoGrid.Utils.@pstrip-Tuple{Any, Vararg{Any, N} where N}","page":"Utilities","title":"CryoGrid.Utils.@pstrip","text":"@pstrip(expr, kwargs...)\n\nConvenience macro for Utils.pstrip; equivalent to pstrip(expr, kwargs...).\n\n\n\n\n\n","category":"macro"},{"location":"api/utils/#CryoGrid.Utils.@setscalar-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@setscalar","text":"Convenience macro for setting scalar (single-element) arrays/vectors. It turns an expression of the form:     a.b = ... into     a.b[1] = ...\n\nThis is primarily intended for code clarity, i.e to clearly discern scalar and non-scalar values.\n\n\n\n\n\n","category":"macro"},{"location":"api/utils/#CryoGrid.Utils.@sym_str-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@sym_str","text":"sym_str(val)\n\nConvenience macro, sym\"val\", for creating a Symbol from val. Equivalent to Symbol(val). Use in situations where normal Julia :val syntax is not possible, e.g. sym\"1\" instead of Symbol(1) or sym\"my.var\" instead of Symbol(\"my.var\").\n\n\n\n\n\n","category":"macro"},{"location":"api/utils/#CryoGrid.Utils.@threaded-Tuple{Any}","page":"Utilities","title":"CryoGrid.Utils.@threaded","text":"Prepends expr with Threads.@threads if and only if Threads.nthreads() > 1, thus avoiding the overhead of @threads when running in single-threaded mode.\n\nCredit to @ranocha (Hendrik Ranocha) https://discourse.julialang.org/t/overhead-of-threads-threads/53964/22\n\n\n\n\n\n","category":"macro"},{"location":"api/#Index-of-public-API","page":"Index","title":"Index of public API","text":"","category":"section"},{"location":"api/","page":"Index","title":"Index","text":"","category":"page"},{"location":"api/hydrology/#Hydrology","page":"Hydrology","title":"Hydrology","text":"","category":"section"},{"location":"api/hydrology/","page":"Hydrology","title":"Hydrology","text":"Modules = [Hydrology]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/hydrology/#CryoGrid.Physics.Hydrology.BucketScheme","page":"Hydrology","title":"CryoGrid.Physics.Hydrology.BucketScheme","text":"BucketScheme{Tfc} <: WaterFlow\n\n\"Bucket\" water scheme for downward advective flow due to gravity.\n\n\n\n\n\n","category":"type"},{"location":"api/hydrology/#CryoGrid.Physics.Hydrology.DampedET","page":"Hydrology","title":"CryoGrid.Physics.Hydrology.DampedET","text":"DampedET{Tftr,Tfev,Tdtr,Tdev}\n\nCorresponds to evapotranspiration scheme 2 described in section 2.2.4 of Westermann et al. (2022).\n\n\n\n\n\n","category":"type"},{"location":"api/hydrology/#CryoGrid.Physics.Hydrology.Evapotranspiration","page":"Hydrology","title":"CryoGrid.Physics.Hydrology.Evapotranspiration","text":"Evapotranspiration\n\nBase type for parameterizations of evapotranspiration (ET).\n\n\n\n\n\n","category":"type"},{"location":"api/hydrology/#CryoGrid.Physics.Hydrology.HydraulicProperties","page":"Hydrology","title":"CryoGrid.Physics.Hydrology.HydraulicProperties","text":"HydraulicProperties\n\nMaterial hydraulic properties.\n\n\n\n\n\n","category":"type"},{"location":"api/hydrology/#CryoGrid.Physics.Hydrology.Rainfall","page":"Hydrology","title":"CryoGrid.Physics.Hydrology.Rainfall","text":"Rainfall{Train<:Forcing{u\"m/s\"}} <: BoundaryProcess{WaterBalance}\n\nBasic rainfall boundary condition for WaterBalance which simply invokes the given precipitation forcing at the current time t.\n\n\n\n\n\n","category":"type"},{"location":"api/hydrology/#CryoGrid.Physics.Hydrology.WaterBalance","page":"Hydrology","title":"CryoGrid.Physics.Hydrology.WaterBalance","text":"WaterBalance{TFlow<:WaterFlow,TET<:Union{Nothing,Evapotranspiration},Tdt,Tsp,TProp} <: CryoGrid.SubSurfaceProcess\n\nRepresents subsurface water transport processes.\n\n\n\n\n\n","category":"type"},{"location":"api/hydrology/#CryoGrid.Physics.Hydrology.WaterBalanceProperties","page":"Hydrology","title":"CryoGrid.Physics.Hydrology.WaterBalanceProperties","text":"WaterBalanceProperties\n\nNumerical constants shared across water balance implementations.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#toplevel","page":"Method interface","title":"Top level methods and types","text":"","category":"section"},{"location":"api/toplevel/","page":"Method interface","title":"Method interface","text":"Modules = [CryoGrid]\nPrivate = false\nOrder = [:type, :constant, :function, :macro]","category":"page"},{"location":"api/toplevel/#CryoGrid.Bottom","page":"Method interface","title":"CryoGrid.Bottom","text":"Bottom{TProc<:BoundaryProcesses} <: Layer{TProc}\n\nGeneric \"bottom\" layer that marks the lower boundary of the subsurface grid.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.BoundaryProcess","page":"Method interface","title":"CryoGrid.BoundaryProcess","text":"BoundaryProcess{T<:SubSurfaceProcess}\n\nAbstract base type for boundary processes, i.e. processes that operate at the boundaries of the subsurface. A BoundaryProcess represents the boundary conditions of one or more SubSurfaceProcesses but may include its own diagnostic (or even prognostic) variables, if necessary.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.Coupled2","page":"Method interface","title":"CryoGrid.Coupled2","text":"Coupled2{P1,P2} = CoupledProcesses{Tuple{T1,T2}} where {T1,T2}\n\nType alias for coupled processes, i.e. CoupledProcesses{Tuple{P1,P2}}. Coupled provides a simple mechanism for defining new behaviors on multi-processes systems.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.CoupledProcesses","page":"Method interface","title":"CryoGrid.CoupledProcesses","text":"CoupledProcesses{TProcs} <: Process\n\nRepresents an explicitly or implicitly coupled system of processes. TProcs is always a Tuple of other processes.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.CryoGridProblem","page":"Method interface","title":"CryoGrid.CryoGridProblem","text":"CryoGridProblem{iip,Tu,Tt,Tp,TT,Tcb,Tdf,Tkw} <: SciMLBase.AbstractODEProblem{Tu,Tt,iip}\n\nRepresents a CryoGrid discretized PDE forward model configuration using the SciMLBase/DiffEqBase problem interface.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.CryoGridProblem-2","page":"Method interface","title":"CryoGrid.CryoGridProblem","text":"CryoGridProblem(\n    tile::Tile,\n    u0::ComponentVector,\n    tspan::NTuple{2,Float64},\n    p=nothing;\n    saveat=3600.0,\n    savevars=(),\n    save_everystep=false,\n    save_start=true,\n    save_end=true,\n    step_limiter=CryoGrid.timestep,\n    safety_factor=1,\n    max_step=true,\n    callback=nothing,\n    isoutofdomain=Strat.domain(tile),\n    specialization=SciMLBase.AutoSpecialize,\n    function_kwargs=(),\n    prob_kwargs...\n)\n\nConstructor for CryoGridProblem that automatically generates necessary callbacks for saving diagnostic state variables\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.CryoGridProblem-Tuple{Tile, ComponentArrays.ComponentVector{T, A, Axes} where {T, A, Axes}, Tuple{DateTime, DateTime}, Vararg{Any, N} where N}","page":"Method interface","title":"CryoGrid.CryoGridProblem","text":"CryoGridProblem(tile::Tile, u0::ComponentVector, tspan::NTuple{2,DateTime}, args...;kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.Layer","page":"Method interface","title":"CryoGrid.Layer","text":"Layer{TProc<:Process}\n\nAbstract base type for all layers.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.Process","page":"Method interface","title":"CryoGrid.Process","text":"Abstract base type for all dynamical processes.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.SubSurface","page":"Method interface","title":"CryoGrid.SubSurface","text":"SubSurface{TProc<:SubSurfaceProcesses} <: Layer{TProc}\n\nAbstract base type for layers in the stratigraphy, e.g. soil, snow, pond, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.SubSurfaceProcess","page":"Method interface","title":"CryoGrid.SubSurfaceProcess","text":"SubSurfaceProcess <: Process\n\nAbstract base type for subsurface processes, i.e. processes that operate at or below the surface, such as heat conduction, water infiltration, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.Top","page":"Method interface","title":"CryoGrid.Top","text":"Top{TProc<:BoundaryProcesses} <: Layer{TProc}\n\nGeneric \"top\" layer that marks the upper boundary of the subsurface grid.\n\n\n\n\n\n","category":"type"},{"location":"api/toplevel/#CryoGrid.Coupled-Tuple{Vararg{Process, N} where N}","page":"Method interface","title":"CryoGrid.Coupled","text":"Coupled(ps::Process...)\n\nConstructs a composite/coupled process from one or more processes. Alias for CoupledProcesses(ps...).\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.Coupled-Tuple{Vararg{Type{var\"#s52\"} where var\"#s52\"<:Process, N} where N}","page":"Method interface","title":"CryoGrid.Coupled","text":"Coupled(types::Type{<:Process}...)\n\nConvenince method which constructs a CoupledProcesses type corresponding to each type in types, e.g:\n\nCoupled(SnowMassBalance, HeatBalance) = CoupledProcesses{Tuple{T1,T2}} where {T1<:SnowMassBalance, T2<:HeatBalance}\n\nalso equivalent to Coupled2{<:SnowMassBalance,<:HeatBalance}.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.basevariables-Tuple{Layer, Process}","page":"Method interface","title":"CryoGrid.basevariables","text":"basevariables(layer::Layer, process::Process)\nbasevariables(::Layer)\nbasevariables(::Any)\n\nDefines \"base\" or common variables for a given Layer, Process, or arbitrary user-defined type. This should be used to define mandatory or shared variables that should not be overridden by subtypes. As such, basevariables should generally only be defined once per type hierarchy (aside from the default definitions) and only on abstract or union types. Implementations should return a Tuple of Vars.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.boundaryflux-Tuple{BoundaryProcess, Union{Bottom, Top}, SubSurfaceProcess, SubSurface, Any, Any}","page":"Method interface","title":"CryoGrid.boundaryflux","text":"boundaryflux(bc::BoundaryProcess, b::Union{Top,Bottom}, p::SubSurfaceProcess, sub::SubSurface, sbc, ssub)\nboundaryflux(s::BoundaryStyle, bc::BoundaryProcess, b::Union{Top,Bottom}, p::SubSurfaceProcess, sub::SubSurface, sbc, ssub)\n\nComputes the flux dH/dt at the boundary layer. Calls boundaryflux(BoundaryStyle(B),...) to allow for generic implementations by boundary condition type. Note that this method uses a different argument order convention than interact!. This is intended to faciliate stratigraphy independent implementations of certain boundary conditions (e.g. a simple Dirichlet boundary could be applied in the same manner to both the upper and lower boundary).\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.boundaryvalue-Tuple{BoundaryProcess, Union{Bottom, Top}, SubSurfaceProcess, SubSurfaceProcess, Any, Any}","page":"Method interface","title":"CryoGrid.boundaryvalue","text":"boundaryvalue(bc::BoundaryProcess, lbc::Union{Top,Bottom}, proc::SubSurfaceProcess, lsub::SubSurfaceProcess, sbc, ssub)\n\nComputes the value of the boundary condition specified by bc for the given layer/process combinations. Note that this method uses a different argument order convention than interact!. This is intended to faciliate stratigraphy independent implementations of certain boundary conditions (e.g. a simple Dirichlet boundary could be applied in the same manner to both the upper and lower boundary).\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.criterion!-Tuple{AbstractArray, GridContinuousEvent, Layer, Any}","page":"Method interface","title":"CryoGrid.criterion!","text":"criterion!(out::AbstractArray, ev::GridContinuousEvent, ::Layer, ::Process, state)\n\nEvent criterion for on-grid (i.e. multi-valued) continuous events. The condition for each grid cell should be stored in out.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.criterion-Tuple{Union{ContinuousEvent, DiscreteEvent}, Layer, Any}","page":"Method interface","title":"CryoGrid.criterion","text":"criterion(::Event, ::Layer, ::Process, state)\n\nEvent criterion/condition. Should return a Bool for discrete events. For continuous events, this should be a real-valued function where the event is fired at the zeros/roots.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.diagnosticstep!-Tuple{Layer, Any}","page":"Method interface","title":"CryoGrid.diagnosticstep!","text":"diagnosticstep!(l::Layer, state)\ndiagnosticstep!(l::Layer, p::Process, state)\n\nDefines the diagnostic update for a Process on a given Layer.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.initialcondition!-Tuple{Layer, Any}","page":"Method interface","title":"CryoGrid.initialcondition!","text":"initialcondition!(::Layer, state)\ninitialcondition!(::Layer, ::Process, state)\ninitialcondition!(::Layer, ::Process, state, initializer)\n\nDefines the initial condition for a given Process and/or Layer. initialcondition! should write initial values into all relevant state variables in state.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.initialcondition!-Tuple{Layer, Layer, Any, Any}","page":"Method interface","title":"CryoGrid.initialcondition!","text":"initialcondition!(layer1::Layer, layer2::Layer, state1, state2)\ninitialcondition!(::Layer, ::Process, ::Layer, ::Process, state1, state2)\ninitialcondition!(::Layer, ::Process, ::Layer, ::Process, state1, state2, initializer)\n\nDefines the initial condition for two processes on adjacent layers. initialcondition! should write initial values into all relevant state variables in state.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.initialcondition!-Union{Tuple{P2}, Tuple{P1}, Tuple{Layer, CoupledProcesses{P1}, Layer, CoupledProcesses{P2}, Any, Any}} where {P1, P2}","page":"Method interface","title":"CryoGrid.initialcondition!","text":"initialcondition!(l1::Layer, ps1::CoupledProcesses{P1}, l2::Layer, ps2::CoupledProcesses{P2}, s1, s2) where {P1,P2}\n\nDefault implementation of initialcondition! for coupled process types. Calls each process in sequence.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.interact!-Tuple{Layer, Layer, Any, Any}","page":"Method interface","title":"CryoGrid.interact!","text":"interact!(::Layer, ::Process, ::Layer, ::Process, state1, state2)\n\nDefines a boundary interaction between two processes on adjacent layers. For any interaction, the order of the arguments follows decreasing depth, i.e. the first layer/process is always on top of the second layer/process. This ordering matters and separate dispatches must be provided for interactions in reverse order.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.interact!-Union{Tuple{P2}, Tuple{P1}, Tuple{Layer, CoupledProcesses{P1}, Layer, CoupledProcesses{P2}, Any, Any}} where {P1, P2}","page":"Method interface","title":"CryoGrid.interact!","text":"interact!(l1::Layer, ps1::CoupledProcesses{P1}, l2::Layer, ps2::CoupledProcesses{P2}, s1, s2) where {P1,P2}\n\nDefault implementation of interact! for coupled process (CoupledProcesses) types. Generates a specialized implementation that calls interact! on all pairs of processes between the two layers. Since it is a generated function, the process matching occurs at compile-time and the emitted code will simply be a sequence of interact! calls. Pairs of processes which lack a definition of interact! should be automatically omitted by the compiler.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.observe-Union{Tuple{P}, Tuple{name}, Tuple{Val{name}, Layer, CoupledProcesses{P}, Any}} where {name, P}","page":"Method interface","title":"CryoGrid.observe","text":"observe(::Val{name}, l::Layer, ps::CoupledProcesses{P}, state) where {P}\n\nDefault implementation of observe for coupled process types. Calls each process in sequence.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.observe-Union{Tuple{name}, Tuple{Val{name}, Layer, Any}} where name","page":"Method interface","title":"CryoGrid.observe","text":"observe(::Val{name}, ::Layer, ::Process, state1)\n\nCalled at the end of each step. Can be used by the user to add additional observables via @log without affecting the model implementation. As such, this function should not be used in implementations, but only by users and code which monitors/consumes CryoGrid model outputs.\n\nExample:\n\nobserve(::Val{:meanT}, ::SubSurface, ::HeatBalance, state) = @log meanT = mean(state.T)\n# build model\n...\nsetup = Tile(stratigraphy, grid, observed=[:meanT])\n# solve\n...\n# retrieve results\n@show out.log.meanT # will be a DimArray of meanT at each timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.processes-Tuple{Layer}","page":"Method interface","title":"CryoGrid.processes","text":"processes(l::Layer)\n\nFetches the process attached to this layer, if any. Default implementation retrieves the proc field on the given layer l. Two or more processes may be attached as a CoupledProcess.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.prognosticstep!-Tuple{Layer, Any}","page":"Method interface","title":"CryoGrid.prognosticstep!","text":"prognosticstep!(l::Layer, p::Process, state)\n\nDefines the prognostic update for a Process on a given layer. Note that an instance of prognosticstep! must be provided for all non-boundary (subsurface) processes/layers.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.timestep-Tuple{Layer, Any}","page":"Method interface","title":"CryoGrid.timestep","text":"timestep(::Layer, ::Process, state)\n\nRetrieves the recommended timestep for the given Process defined on the given Layer. The default implementation returns Inf which indicates no timestep restriction. The actual chosen timestep will depend on the integrator being used and other user configuration options.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.timestep-Union{Tuple{P}, Tuple{Layer, CoupledProcesses{P}, Any}} where P","page":"Method interface","title":"CryoGrid.timestep","text":"timestep(l::Layer, ps::CoupledProcesses{P}, state) where {P}\n\nDefault implementation of timestep for coupled process types. Calls each process in sequence.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.trigger!-Tuple{CryoGrid.Event, Layer, Any}","page":"Method interface","title":"CryoGrid.trigger!","text":"trigger!(::Event, ::Layer, ::Process, state)\ntrigger!(ev::ContinuousEvent, ::ContinuousTrigger, ::Layer, ::Process, state)\ntrigger!(ev::GridContinuousEvent, ::ContinuousTrigger, ::Layer, ::Process, state)\n\nEvent action executed when criterion is met.\n\n\n\n\n\n","category":"method"},{"location":"api/toplevel/#CryoGrid.variables-Tuple{Layer, Process}","page":"Method interface","title":"CryoGrid.variables","text":"variables(layer::Layer, process::Process)\nvariables(::Layer)\nvariables(::Any)\n\nDefines variables for a given Layer, Process, or arbitrary user-defined type. Implementations should return a Tuple of Vars.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#Numerics","page":"Numerics","title":"Numerics","text":"","category":"section"},{"location":"api/numerics/","page":"Numerics","title":"Numerics","text":"DocTestSetup = quote\n    using CryoGrid\nend","category":"page"},{"location":"api/numerics/","page":"Numerics","title":"Numerics","text":"Modules = [CryoGrid.Numerics]\nPrivate = true\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/numerics/#CryoGrid.Numerics.Algebraic","page":"Numerics","title":"CryoGrid.Numerics.Algebraic","text":"Algebraic{name,S,T,units,domain} <: Var{name,S,T,units,domain}\n\nDefines an algebraic (implicit) state variable.\n\n\n\n\n\n","category":"type"},{"location":"api/numerics/#CryoGrid.Numerics.Delta","page":"Numerics","title":"CryoGrid.Numerics.Delta","text":"Delta{dname,name,S,T,units,domain} <: Var{dname,S,T,units,domain}\n\nDefines a \"delta\" term du for variable u, which is the time-derivative/divergence for prognostic variables or the residual for algebraic variables.\n\n\n\n\n\n","category":"type"},{"location":"api/numerics/#CryoGrid.Numerics.Diagnostic","page":"Numerics","title":"CryoGrid.Numerics.Diagnostic","text":"Diagnostic{name,S,T,units,domain} <: Var{name,S,T,units,domain}\n\nDefines a diagnostic variable which is allocated and cached per timestep but not integrated over time.\n\n\n\n\n\n","category":"type"},{"location":"api/numerics/#CryoGrid.Numerics.DiffCache","page":"Numerics","title":"CryoGrid.Numerics.DiffCache","text":"DiffCache{TCache}\n\nWrapper around PreallocationTools.DiffCache that stores state variables in forward-diff compatible cache arrays.\n\n\n\n\n\n","category":"type"},{"location":"api/numerics/#CryoGrid.Numerics.Grid","page":"Numerics","title":"CryoGrid.Numerics.Grid","text":"struct Grid{S,G,Q,A} <: AbstractDiscretization{Q,1}\n\nRepresents the 1D spatial discretization on which time integration is performed. S is a GridSpec, either Edges or Cells (always edges upon initial construction). The grid representation can be converted (allocation free) between grid edges and cells via the cells and edges methods. G represents the geometry/volume on which the vertical 1D discretization is applied. A is the underlying array type, and Q is the numerical type (e.g. Float64 or a Unitful.Quantity).\n\n\n\n\n\n","category":"type"},{"location":"api/numerics/#CryoGrid.Numerics.Prognostic","page":"Numerics","title":"CryoGrid.Numerics.Prognostic","text":"Prognostic{name,S,T,units,domain} <: Var{name,S,T,units,domain}\n\nDefines a prognostic (time-integrated) state variable.\n\n\n\n\n\n","category":"type"},{"location":"api/numerics/#CryoGrid.Numerics.VarStates","page":"Numerics","title":"CryoGrid.Numerics.VarStates","text":"VarStates{names,griddvars,TU,TD,TV,DF,DG}\n\nGeneric container for holding discretized state arrays for declared variables (Var types), as well as the prototype prognostic state vector (uproto).\n\n\n\n\n\n","category":"type"},{"location":"api/numerics/#CryoGrid.Numerics.VarStates-Union{Tuple{A}, Tuple{NamedTuple{names, var\"#s121\"} where {names, var\"#s121\"<:Tuple{Vararg{Tuple{Vararg{CryoGrid.Numerics.Var, N} where N}, N} where N}}, CryoGrid.Numerics.AbstractDiscretization, Int64}, Tuple{NamedTuple{names, var\"#s121\"} where {names, var\"#s121\"<:Tuple{Vararg{Tuple{Vararg{CryoGrid.Numerics.Var, N} where N}, N} where N}}, CryoGrid.Numerics.AbstractDiscretization, Int64, Type{A}}} where A<:(AbstractVector{T} where T)","page":"Numerics","title":"CryoGrid.Numerics.VarStates","text":"VarStates(vars::GroupedVars, D::Numerics.AbstractDiscretization, chunk_size::Int, arrayproto::Type{A}=Vector) where {A<:AbstractVector}\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.build_mass_matrix-Tuple{CryoGrid.Numerics.VarStates}","page":"Numerics","title":"CryoGrid.Numerics.build_mass_matrix","text":"build_mass_matrix(u::ComponentVector, states::VarStates)\n\nConstructs a mass matrix M‚ãÖ‚àÇu‚àÇt = f(u) suitable for the prognostic state vector u based on the defined variable types.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.discretize-Union{Tuple{A}, Tuple{D}, Tuple{N}, Tuple{T}, Tuple{Q}, Tuple{Type{A}, D, CryoGrid.Numerics.Var}} where {Q, T, N, D<:CryoGrid.Numerics.AbstractDiscretization{Q, N}, A<:AbstractArray{T, N}}","page":"Numerics","title":"CryoGrid.Numerics.discretize","text":"discretize([::Type{A}], ::T,  ::Var) where {T,N,D<:AbstractDiscretization{T,N},A<:AbstractArray{T,N}}\n\nProduces a discretization of the given variable based on T and array type A.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.divergence!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T}","page":"Numerics","title":"CryoGrid.Numerics.divergence!","text":"divergence!(dx::AbstractVector, j::AbstractVector, Œîj::AbstractVector)\n\nCalculates the first-order divergence over a 1D flux vector field j and grid cell lengths Œîj. Divergences are added to existing values in dx.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.dual-Union{Tuple{tag}, Tuple{Number, Type{tag}}} where tag","page":"Numerics","title":"CryoGrid.Numerics.dual","text":"dual(x::Number, ::Type{tag}) where {tag}\ndual(x::A, ::Type{tag}) where {N,T,A<:SVector{N,T},tag}\n\nConstructs a ForwardDiff.Dual number (or static array thereof) with tag from x.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.flux!-NTuple{4, AbstractVector{T} where T}","page":"Numerics","title":"CryoGrid.Numerics.flux!","text":"flux!(j::AbstractVector, x::AbstractVector, Œîx::AbstractVector, k::AbstractVector)\n\nCalculates the first-order, non-linear spatial flux over a discretized variable x with conductivity k. x is assumed to have shape (N,), Œîx shape (N-1,), and j and k shape (N+1,) such that j[2:end-1] represents the fluxes over the inner grid cell faces. Fluxes are added to existing values in j.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.harmonicmean!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T}","page":"Numerics","title":"CryoGrid.Numerics.harmonicmean!","text":"harmonicmean!(h::AbstractVector, x::AbstractVector, w::AbstractVector)\n\nVectorized harmonic mean of elements in x with weights w. Output is stored in h, which should have size length(x)-1.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.harmonicmean-NTuple{4, Any}","page":"Numerics","title":"CryoGrid.Numerics.harmonicmean","text":"harmonicmean(x‚ÇÅ, x‚ÇÇ, w‚ÇÅ, w‚ÇÇ)\n\nSimple weighted harmonic mean of two values, x‚ÇÅ and x‚ÇÇ.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.heaviside-Tuple{Any}","page":"Numerics","title":"CryoGrid.Numerics.heaviside","text":"heaviside(x)\n\nDifferentiable implementation of heaviside step function, i.e:\n\nh(x) = begincases 1  x  0  0  x  0 endcases\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.logistic-Tuple{Any}","page":"Numerics","title":"CryoGrid.Numerics.logistic","text":"logistic(x)\n\nNumerically stable logistic function.\n\nœÉ(x) = begincases frac11+exp(-x)  x  0  fracexp(x)1+exp(x)  x  0 endcases\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.logit-Tuple{Any}","page":"Numerics","title":"CryoGrid.Numerics.logit","text":"logit(x)\n\nNumerically stable logit function. True domain is (0,1) but inputs are clamped to (œµ,1-œµ) for numerical convenience, making the effective domain (-‚àû,‚àû).\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.nonlineardiffusion!-NTuple{6, AbstractVector{T} where T}","page":"Numerics","title":"CryoGrid.Numerics.nonlineardiffusion!","text":"nonlineardiffusion!(dx::AbstractVector, j::AbstractVector, x::AbstractVector, Œîx::AbstractVector, k::AbstractVector, Œîk::AbstractVector)\n\nFast alternative to flux! and divergence! which computes fluxes and divergences (via _flux_kernel and _div_kernel) in a single pass. Note, however, that loop vectorization with @turbo is not possible because of necessary loop-carried dependencies. Fluxes and divergences are added to the existing values stored in j and dx.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.softplus-Tuple{Any}","page":"Numerics","title":"CryoGrid.Numerics.softplus","text":"softplus(x)\n\nNumerically stable softplus function.\n\ns(x) = log(1+exp(-x)) + max(xœµ)\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.softplusinv-Tuple{Any}","page":"Numerics","title":"CryoGrid.Numerics.softplusinv","text":"softplusinv(x)\n\nNumerically stable softplus inverse function. True domain is (0,‚àû) but inputs are clamped to (œµ,‚àû) for numerical convenience, making the effective domain (-‚àû,‚àû).\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.tdma_solve!","page":"Numerics","title":"CryoGrid.Numerics.tdma_solve!","text":"tdma_solve!(x, a, b, c, d)\n\nTridiagonal matrix solver via the Thomas algorithm; adapted from original CryoGridLite implementation. Modifies all input vectors in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/numerics/#CryoGrid.Numerics.updategrid!-Union{Tuple{Grid{CryoGrid.Numerics.Edges, G, Q, A} where A}, Tuple{Q}, Tuple{G}, Tuple{Grid{CryoGrid.Numerics.Edges, G, Q, A} where A, AbstractVector{Q}}} where {G, Q}","page":"Numerics","title":"CryoGrid.Numerics.updategrid!","text":"updategrid!(grid::Grid{Edges,G,Q}, vals::Q=grid) where {G,Q}\n\nOverwrites grid edges with vals, and recomputes grid centers/deltas to be consistent with the new grid.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.‚àá-Union{Tuple{F}, Tuple{F, AbstractArray}} where F","page":"Numerics","title":"CryoGrid.Numerics.‚àá","text":"‚àá(f::F, x::AbstractArray) where {F}\n\nTakes a function y = f(x) and vector-valued argument x and returns a tuple: (y, ‚àá‚Çìy). The gradient is calculated using forward-mode automatic differentiation.\n\n\n\n\n\n","category":"method"},{"location":"api/numerics/#CryoGrid.Numerics.‚àá-Union{Tuple{F}, Tuple{F, Number}} where F","page":"Numerics","title":"CryoGrid.Numerics.‚àá","text":"‚àá(f::F, x::Number) where {F}\n\nTakes a function y = f(x) and argument x and returns a tuple: (y, ‚àÇy‚àÇx). The derivative is calculated using forward-mode automatic differentiation.\n\n\n\n\n\n","category":"method"},{"location":"api/strat/#Strat","page":"Stratigraphy","title":"Strat","text":"","category":"section"},{"location":"api/strat/","page":"Stratigraphy","title":"Stratigraphy","text":"This module contains the Stratigraphy, Tile, and related types for building and evaluating a CryoGrid 1-D process model.","category":"page"},{"location":"api/strat/","page":"Stratigraphy","title":"Stratigraphy","text":"Modules = [Strat]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/strat/#CryoGrid.Strat.InterpInitializer","page":"Stratigraphy","title":"CryoGrid.Strat.InterpInitializer","text":"InterpInitializer{varname,P,I,E} <: VarInitializer{varname}\n\nInitializer for on-grid variables that takes a Profile as initial values and interpolates along the model grid. The interpolation mode is linear by default, but can also be any other Gridded interpolation mode supported by Interpolations.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/strat/#CryoGrid.Strat.JacobianStyle","page":"Stratigraphy","title":"CryoGrid.Strat.JacobianStyle","text":"JacobianStyle\n\nTrait for indicating Jacobian sparsity of a CryoGrid ODEProblem.\n\n\n\n\n\n","category":"type"},{"location":"api/strat/#CryoGrid.Strat.JacobianStyle-Tuple{Type{var\"#s280\"} where var\"#s280\"<:Tile}","page":"Stratigraphy","title":"CryoGrid.Strat.JacobianStyle","text":"JacobianStyle(::Type{<:Tile})\n\nCan be overriden/extended to specify Jacobian structure for specific Tiles.\n\n\n\n\n\n","category":"method"},{"location":"api/strat/#CryoGrid.Strat.LayerState","page":"Stratigraphy","title":"CryoGrid.Strat.LayerState","text":"LayerState{iip,TGrid,TStates,TGrids,Tt,Tdt,Tz,varnames}\n\nRepresents the state of a single component (layer + processes) in the stratigraphy.\n\n\n\n\n\n","category":"type"},{"location":"api/strat/#CryoGrid.Strat.Stratigraphy","page":"Stratigraphy","title":"CryoGrid.Strat.Stratigraphy","text":"Stratigraphy{N,TLayers,TBoundaries}\n\nDefines a 1-dimensional stratigraphy by connecting a top and bottom layer to one or more subsurface layers.\n\n\n\n\n\n","category":"type"},{"location":"api/strat/#CryoGrid.Strat.Tile","page":"Stratigraphy","title":"CryoGrid.Strat.Tile","text":"Tile{TStrat,TGrid,TStates,TInits,TEvents,iip,obsv} <: AbstractTile{iip}\n\nDefines the full specification of a single CryoGrid tile; i.e. stratigraphy, grid, and state variables.\n\n\n\n\n\n","category":"type"},{"location":"api/strat/#CryoGrid.Strat.Tile-Union{Tuple{A}, Tuple{Stratigraphy, Grid{CryoGrid.Numerics.Edges, var\"#s261\", var\"#s260\", A} where {var\"#s261\"<:CryoGrid.Numerics.Geometry, var\"#s260\"<:(Quantity{T, ùêã, U} where {T, U<:(Unitful.FreeUnits{N, ùêã, nothing} where N)}), A}, Vararg{CryoGrid.Strat.VarInitializer, N} where N}} where A<:AbstractArray","page":"Stratigraphy","title":"CryoGrid.Strat.Tile","text":"Tile(\n    @nospecialize(strat::Stratigraphy),\n    @nospecialize(grid::Grid{Edges,<:Numerics.Geometry,<:DistQuantity}),\n    @nospecialize(inits::VarInitializer...);\n    arrayproto::Type{A}=Vector,\n    iip::Bool=true,\n    observe::Vector{Symbol}=Symbol[],\n    chunk_size=nothing,\n)\n\nConstructs a Tile from the given stratigraphy and grid. arrayproto keyword arg should be an array instance (of any arbitrary length, including zero, contents are ignored) that will determine the array type used for all state vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/strat/#CryoGrid.Strat.TileState","page":"Stratigraphy","title":"CryoGrid.Strat.TileState","text":"TileState{iip,TGrid,TStates,Tt,Tdt,names}\n\nRepresents the instantaneous state of a CryoGrid Tile.\n\n\n\n\n\n","category":"type"},{"location":"api/strat/#CryoGrid.Strat.getstate","page":"Stratigraphy","title":"CryoGrid.Strat.getstate","text":"getstate(layername::Symbol, tile::Tile, u, du, t)\ngetstate(::Val{layername}, tile::Tile{TStrat,TGrid,<:VarStates{layernames},iip}, _u, _du, t)\n\nConstructs a LayerState representing the full state of layername given tile, state vectors u and du, and the time step t.\n\n\n\n\n\n","category":"function"},{"location":"api/strat/#CryoGrid.Strat.initializer-Tuple{Symbol, Number}","page":"Stratigraphy","title":"CryoGrid.Strat.initializer","text":"initializer(varname::Symbol, x::Number) => FunctionInitializer w/ constant\ninitializer(varname::Symbol, f::Function) => FunctionInitializer\ninitializer(varname::Symbol, profile::Profile, interp=Linear(), extrap=Flat()) => InterpInitializer\n\nConvenience constructor for VarInitializer that selects the appropriate initializer type based on the arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/strat/#CryoGrid.Strat.stratiterate-Union{Tuple{TLayers}, Tuple{N}, Tuple{F}, Tuple{F, Stratigraphy{N, TLayers, TBoundaries} where TBoundaries, Any}} where {F, N, TLayers}","page":"Stratigraphy","title":"CryoGrid.Strat.stratiterate","text":"stratiterate(f!::F, strat::Stratigraphy{N,TLayers}, state) where {F,N,TLayers}\n\nstratiterate invokes the user-supplied function f!(layer1, layer2, state1, state2) on each pair of layers in the stratigraphy which are adjacent and \"active\" based on the current state. state must have properties defined corresponding to the name of each layer such that getproperty(state, layername(strat[i])) would return the appropriate state object for the i'th layer in the stratigraphy.\n\n\n\n\n\n","category":"method"},{"location":"api/strat/#CryoGrid.Strat.withaxes-Tuple{AbstractArray, Tile}","page":"Stratigraphy","title":"CryoGrid.Strat.withaxes","text":"withaxes(u::AbstractArray, ::Tile)\n\nConstructs a ComponentArray with labeled axes from the given state vector u. Assumes u to be of the same type/shape as setup.uproto.\n\n\n\n\n\n","category":"method"},{"location":"api/strat/#CryoGrid.Strat.@Stratigraphy-Tuple","page":"Stratigraphy","title":"CryoGrid.Strat.@Stratigraphy","text":"Convenience macro for defining stratigraphies with multiple subsurface layers.\n\n\n\n\n\n","category":"macro"},{"location":"api/boundaries/#Boundary-conditions-and-forcings","page":"Boundary conditions and forcings","title":"Boundary conditions and forcings","text":"","category":"section"},{"location":"api/boundaries/","page":"Boundary conditions and forcings","title":"Boundary conditions and forcings","text":"Modules = [Boundaries]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/boundaries/#CryoGrid.Physics.Boundaries.Bias","page":"Boundary conditions and forcings","title":"CryoGrid.Physics.Boundaries.Bias","text":"Bias{P,Tb} <: BoundaryProcess{P}\n\nBoundary process which adds a constant shift/offset to the boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"api/boundaries/#CryoGrid.Physics.Boundaries.BoundaryEffect","page":"Boundary conditions and forcings","title":"CryoGrid.Physics.Boundaries.BoundaryEffect","text":"BoundaryEffect\n\nBase type for boundary \"effects\" which modify boundary conditions based on some given parameterization.\n\n\n\n\n\n","category":"type"},{"location":"api/boundaries/#CryoGrid.Physics.Boundaries.ConstantBC","page":"Boundary conditions and forcings","title":"CryoGrid.Physics.Boundaries.ConstantBC","text":"ConstantBC{P,S,T} <: BoundaryProcess{P}\n\nConstant boundary condition (of any type/unit) specified by value.\n\n\n\n\n\n","category":"type"},{"location":"api/boundaries/#CryoGrid.Physics.Boundaries.PeriodicBC","page":"Boundary conditions and forcings","title":"CryoGrid.Physics.Boundaries.PeriodicBC","text":"PeriodicBC{P,S,T1,T2,T3,T4} <: BoundaryProcess{P}\n\nPeriodic boundary condition (of any type/unit) specified by period, amplitude, and phaseshift.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers","title":"Solvers","text":"Modules = [CryoGrid.DiffEq,CryoGrid.LiteImplicit]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/solvers/#CryoGrid.DiffEq.CryoGridEnsembleSetup","page":"Solvers","title":"CryoGrid.DiffEq.CryoGridEnsembleSetup","text":"CryoGridEnsembleSetup{TTile<:Tile,Tkwargs}\n\nStores the basic model configuration for a CryoGrid single-tile ensemble.\n\nSee also CryoGridEnsembleProblem, fitekp!\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#CryoGrid.DiffEq.CryoGridEnsembleProblem","page":"Solvers","title":"CryoGrid.DiffEq.CryoGridEnsembleProblem","text":"CryoGridEnsembleProblem(\n    setup::CryoGridEnsembleSetup,\n    Œ¶::AbstractMatrix,\n    param_map::ParameterMapping=ParameterMapping();\n    output_dir=\".\",\n    prob_func=default_ensemble_prob_func(setup),\n    output_func=default_ensemble_output_func(output_dir, \"cryogrid_ensemble_run\"),\n    reduction=(u,data,i) -> (append!(u,data),false),\n    ensprob_kwargs...\n)\n\nConstructs an EnsembleProblem from the given ensemble setup for a m x N parameter matrix Œ¶, where N is the size of the ensemble and m is the dimensionality of the ensmeble state space (e.g. the number of parameters). param_map must be a ParameterMapping with a transform function that accepts an m-dimensional vector and produces a parameter vector (or CryoGridParams instance) which matches the output of CryoGrid.parameters. By default, param_map is the identity function; however, it may be customized to permit the construction of reduced-rank or reparameterized ensembles for which the parameter space differs from the full CryoGrid model parameter space.\n\nKeyword arguments:\n\noutput_func: a function (sol,i)::Any which processes the ODESolution for ensemble member i and returns the result. It is recommended to save output to disk for non-trivial time spans to avoid slowdowns from serialization time when running the ensemble using parallel workers.\n\nreduction: a function (u,data,i) which accumulates the result of output_func in u. Defaults to just appending data to u.\n\noutput_dir: Only used to specify the output directory for the default implementation of output_func. If a custom output_func is provided, this arugment is ignored.\n\nAll additional keyword arguments will be passed to EnsembleProblem.\n\nSee also SciMLBase.EnsembleProblem, CryoGridEnsembleSetup, fitekp!\n\n\n\n\n\n","category":"function"},{"location":"manual/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"manual/overview/#Setting-up-a-model","page":"Overview","title":"Setting up a model","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"At the highest level, a model in CryoGrid.jl is defined by a Grid and a Stratigraphy, constructed top-down from individual Layers, each of which has one or more Processes. Each layer in the Stratigraphy is assigned a depth, which then aligns it with the Grid. All models must consist of at least three layers/nodes: Top and Bottom layers with corresponding boundary conditions, as well as one or more SubSurface layers. Here we define a simple three-layer model (or one-layer, exlcuding the boundaries) with a single sub-surface process, i.e. HeatBalance (heat conduction):","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"# ... load forcings, set up profiles, etc.\n# see examples/heat_vgfc_seb_saoylov_custom.jl for more details\nstrat = Stratigraphy(\n    -2.0u\"m\" => Top(SurfaceEnergyBalance(Tair,pr,q,wind,Lin,Sin,z)),\n    0.0u\"m\" => Soil(soilprofile, HeatBalance(:H;freezecurve=SFCC(DallAmico()))),\n    1000.0u\"m\" => Bottom(GeothermalHeatFlux(0.053u\"J/s/m^2\"))\n);\ngrid = CryoGrid.Presets.DefaultGrid_5cm\n# define initial conditions for temperature using a given profile;\n# The default initializer linearly interpolates between profile points.\ninitT = initializer(:T, tempprofile)\ntile = Tile(strat, grid, initT);","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"This model can then be used to construct an ODEProblem (from DiffEqBase.jl) via the CryoGridProblem constructor:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"tspan = (DateTime(2010,10,30),DateTime(2011,10,30))\np = parameters(tile)\nu0 = initialcondition!(tile, tspan, p, initT)\nprob = CryoGridProblem(tile, u0, tspan, p, savevars=(:T,)) # produces an ODEProblem with problem type CryoGridODEProblem","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"It can then be solved simply using the solve function (also from DiffEqBase and OrdinaryDiffEq):","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"# solve with forward Euler (fixed 5 minute time steps) and construct CryoGridOutput from solution\nout = @time solve(prob, Euler(), dt=5*60.0, saveat=24*3600.0, progress=true) |> CryoGridOutput;","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"The result is a CryoGridOutput type which provides DimArrays containing the model outputs over time and space:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"julia> out.T\n278√ó366 DimArray{Float64,2} with dimensions: \n  Z: Quantity{Float64, ùêã, Unitful.FreeUnits{(m,), ùêã, nothing}}[0.01 m, 0.03 m, ‚Ä¶, 850.0 m, 950.0 m] Sampled: Ordered Irregular Points,\n  Ti (Time): DateTime[2010-10-30T00:00:00, ‚Ä¶, 2011-10-30T00:00:00] Sampled: Ordered Irregular Points","category":"page"},{"location":"manual/overview/#Defining-model-behavior","page":"Overview","title":"Defining model behavior","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Notice that, in the example above, it is types such as Soil, HeatBalance, SFCC, etc. that specify which components the model should use. These components are defined by adding method dispatches to the core model API methods. State variables are declared via the variables method, e.g:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"\"\"\" Variable definitions for heat conduction (enthalpy) on soil layer. \"\"\"\nvariables(soil::Soil, heat::HeatBalance{:H}) = (\n    Prognostic(:H, OnGrid(Cells), u\"J/m^3\"),\n    Diagnostic(:T, OnGrid(Cells), u\"¬∞C\"),\n    Diagnostic(:C, OnGrid(Cells), u\"J//K*/m^3\"),\n    Diagnostic(:‚àÇH‚àÇT, OnGrid(Cells), u\"J/K/m^3\"),\n    Diagnostic(:k, OnGrid(Edges), u\"W/m/K\"),\n    Diagnostic(:kc, OnGrid(Cells), u\"W//m/K\"),\n    # this last line just appends any state variables or parameters\n    # defined by the freeze curve to the tuple.\n    variables(soil, heat, freezecurve(heat))...,\n)","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"When the HeatBalance process is assigned to a Soil layer, Tile will invoke this method and create state variables corresponding to each Var. Prognostic variables are assigned derivatives (in this case, ‚àÇH‚àÇt, since H is the prognostic state variable) and integrated over time. Diagnostic variables provide in-place caches for intermediary variables/computations and can be automatically tracked by the modeling engine.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Each variable definition consists of a name (a Julia Symbol), a type, and a shape. For variables discretized on the grid, the shape is specified by OnGrid, which will generate an array of the appropriate size when the model is compiled. The arguments Cells and Edges specify whether the variable should be defined on the grid cells or edges respecitvely.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"The real work finally happens in diagnosticstep! and prognosticstep!, the latter of which should be used to compute the time derivatives (here ‚àÇH‚àÇt). interact! defines the behavior at the boundaries and should be used to compute the derivatives (and any other necessary values) at the interface between layers.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"We can take as an example the implementation of prognosticstep! for enthalpy-based heat conduction (note that jH is a diagnostic variable representing the energy flux over each cell edge):","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"function CryoGrid.prognosticstep!(::SubSurface, ::HeatBalance{<:FreezeCurve,<:Enthalpy}, state)\n    Œîk = Œî(state.grids.k) # cell sizes\n    ŒîT = Œî(state.grids.T) # midpoint distances\n    # compute internal fluxes and non-linear diffusion assuming boundary fluxes have been set\n    nonlineardiffusion!(state.‚àÇH‚àÇt, state.jH, state.T, ŒîT, state.k, Œîk)\n    return nothing\nend","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"warning: Warning\nPrognostic state variables like H in the example above should not be directly modified in user code. This is especially important when using higher order or implicit integrators as unexpected changes to prognostic state may destroy the accuracy of their internal interpolant. For modeling discontinuities, use Events instead.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Note that state is of type LayerState with fields corresponding to the variables declared by the variables function for Soil and HeatBalance. Additionally, output arrays for the time derivatives are provided (here ‚àÇH‚àÇt), as well as the current timestep, layer boundary depths, and variable grids (accessible via state.t, state.bounds, and state.grids respectively). Note that state will also contain other variables declared on this Soil layer by other SubSurfaceProcesses, allowing for implicit coupling between processes where appropriate.","category":"page"},{"location":"api/heat_conduction/#Heat-conduction","page":"Heat Conduction","title":"Heat conduction","text":"","category":"section"},{"location":"api/heat_conduction/","page":"Heat Conduction","title":"Heat Conduction","text":"Modules = [Heat]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.HeatBalance","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.HeatBalance","text":"HeatBalance{Tfc<:FreezeCurve,THeatOp<:HeatOperator,Tdt,Tprop} <: SubSurfaceProcess\n\nRepresents subsurface heat transfer processes. The formulation of heat transfer is governed by the HeatOperator, op and \n\n\n\n\n\n","category":"type"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.HeatProperties","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.HeatProperties","text":"Numerical constants for pararameterizing heat processes.\n\n\n\n\n\n","category":"type"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.StefanProblem","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.StefanProblem","text":"StefanProblem{Tp<:StefanParameters,Tx,Tt}\n\nRepresents the simple two-phase Stefan problem defined on a semi-infinite slab. The one-phase Stefan problem can be computed by setting the parameters T_s = T_m.\n\n\n\n\n\n","category":"type"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.ThermalProperties","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.ThermalProperties","text":"ThermalProperties\n\nMaterial thermal properties.\n\n\n\n\n\n","category":"type"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.TemperatureProfile-Tuple{Vararg{Pair{var\"#s118\", var\"#s117\"} where {var\"#s118\"<:Union{Param, Quantity{T, ùêã, U} where {T, U<:(Unitful.FreeUnits{N, ùêã, nothing} where N)}}, var\"#s117\"<:Union{Param, Quantity{T, ùöØ, U} where {T, U<:(Unitful.FreeUnits{N, ùöØ, A} where {N, A})}}}, N} where N}","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.TemperatureProfile","text":"TemperatureProfile(pairs::Pair{<:Union{DistQuantity,Param},<:Union{TempQuantity,Param}}...)\n\nConvenience constructor for Numerics.Profile which automatically converts temperature quantities.\n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.enthalpy-NTuple{4, Any}","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.enthalpy","text":"enthalpy(T, C, L, Œ∏) = T*C + L*Œ∏\n\nDiscrete enthalpy function on temperature, heat capacity, specific latent heat of fusion, and liquid water content.\n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.enthalpyinv-NTuple{4, Any}","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.enthalpyinv","text":"enthalpyinv(H, C, L, Œ∏) = (H - L*Œ∏) / C\n\nDiscrete inverse enthalpy function given H, C, L, and Œ∏.\n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.freezethaw!-Tuple{SubSurface, HeatBalance, Any}","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.freezethaw!","text":"freezethaw!(sub::SubSurface, heat::HeatBalance, state)\n\nCalculates freezing and thawing effects, including evaluation of the freeze curve. In general, this function should compute at least the liquid/frozen water contents and the corresponding heat capacity. Other variables such as temperature or enthalpy should also be computed depending on the thermal scheme being implemented.\n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.freezethaw!-Tuple{SubSurface, HeatBalance{FreeWater, var\"#s117\", Tdt, Tprop} where {var\"#s117\"<:CryoGrid.Physics.Heat.HeatOperator{:H}, Tdt, Tprop}, Any}","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.freezethaw!","text":"freezethaw!(sub::SubSurface, heat::HeatBalance{FreeWater,<:Enthalpy}, state)\n\nImplementation of \"free water\" freezing characteristic for any subsurface layer. Assumes that state contains at least temperature (T), enthalpy (H), heat capacity (C), total water content (Œ∏wi), and liquid water content (Œ∏w).\n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.heatcapacity!-Tuple{SubSurface, HeatBalance, Any}","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.heatcapacity!","text":"heatcapacity!(sub::SubSurface, heat::HeatBalance, state)\n\nComputes the heat capacity for the given layer from the current state and stores the result in-place in the state variable C.\n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.heatcapacity-Tuple{SubSurface, HeatBalance, Vararg{Any, N} where N}","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.heatcapacity","text":"heatcapacity(sub::SubSurface, heat::HeatBalance, Œ∏fracs...)\n\nComputes the heat capacity as a weighted average over constituent capacities with volumetric fractions Œ∏fracs.\n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.thermalconductivity!-Tuple{SubSurface, HeatBalance, Any}","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.thermalconductivity!","text":"thermalconductivity!(sub::SubSurface, heat::HeatBalance, state)\n\nComputes the thermal conductivity for the given layer from the current state and stores the result in-place in the state variable C.\n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.thermalconductivity-Tuple{CryoGrid.Physics.Heat.HeatOperator}","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.thermalconductivity","text":"thermalconductivity(op::HeatOperator)\n\nReturns the thermal conductivity function for the given HeatOperator.\n\n\n\n\n\n","category":"method"},{"location":"api/heat_conduction/#CryoGrid.Physics.Heat.thermalconductivity-Tuple{SubSurface, HeatBalance, Vararg{Any, N} where N}","page":"Heat Conduction","title":"CryoGrid.Physics.Heat.thermalconductivity","text":"thermalconductivity(sub::SubSurface, heat::HeatBalance, Œ∏fracs...)\n\nComputes the thermal conductivity as a squared weighted sum over constituent conductivities with volumetric fractions Œ∏fracs.\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#Quick-start","page":"Getting Started","title":"Quick start","text":"","category":"section"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"After installing CryoGrid.jl, you can get started right away with a simple soil heat model. The Presets module (aliased CryoGrid.Presets) provides pre-specified model configurations that can be obtained with a single function call. It is also possible to modify the soil and initial temperature profiles via SoilLayerConfig; here SamoylovDefault is used.","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Single layer heat conduction model with free water freeze curve and air temperature upper boundary condition:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"using CryoGrid\nusing Plots\n\n# load provided forcing data from Samoylov;\n# The forcing file will be automatically downloaded to the input/ folder if not already present.\nforcings = loadforcings(CryoGrid.Presets.Forcings.Samoylov_ERA_obs_fitted_1979_2014_spinup_extended_2044, :Tair => u\"¬∞C\");\n# use air temperature as upper boundary forcing\ntair = TimeSeriesForcing(ustrip.(forcings.data.Tair), forcings.timestamps, :Tair);\n# get preset soil and initial temperature profile for Samoylov\nsoilprofile, tempprofile = CryoGrid.Presets.SamoylovDefault\n# basic 1-layer heat conduction model (defaults to free water freezing scheme)\nmodel = CryoGrid.Presets.SoilHeatTile(TemperatureGradient(tair), soilprofile)\n# define time span (1 year)\ntspan = (DateTime(2010,10,30),DateTime(2011,10,30))\np = parameters(model)\ninitT = initializer(:T, tempprofile)\nu0 = initialcondition!(model, tspan, p, initT)\n# CryoGrid front-end for ODEProblem\nprob = CryoGridProblem(model,u0,tspan,p,savevars=(:T,))\n# solve discretized system, saving every 6 hours;\n# Trapezoid on a discretized PDE is analogous to the well known Crank-Nicolson method.\nout = @time solve(prob, Trapezoid(), saveat=6*3600.0, progress=true) |> CryoGridOutput;\nzs = [1.0,5,10,20,30,50,100,500,1000]u\"cm\"\ncg = Plots.cgrad(:copper,rev=true)\nplot(out.T[Z(Near(zs))], color=cg[LinRange(0.0,1.0,length(zs))]', ylabel=\"Temperature\", leg=false)","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"(Image: Ts_output_freew)","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Alternatively, we can use a Dall'Amico freeze curve:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"model = CryoGrid.Presets.SoilHeatTile(TemperatureGradient(tair), soilprofile, freezecurve=SFCC(DallAmico()))\n# Set-up parameters\np = parameters(model)\ntspan = (DateTime(2010,10,30),DateTime(2011,10,30))\n# CryoGrid front-end for ODEProblem\nprob = CryoGridProblem(model,u0,tspan,p,savevars=(:T,))\n# stiff solvers don't work well with Dall'Amico due to the ill-conditioned Jacobian;\n# We can just forward Euler instead.\nout = @time solve(prob, Euler(), dt=120.0, saveat=6*3600.0, progress=true) |> CryoGridOutput;\nplot(out.T[Z(Near(zs))], color=cg[LinRange(0.0,1.0,length(zs))]', ylabel=\"Temperature\", leg=false)","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"Note that SoilHeat uses energy as the state variable by default. To use temperature as the state variable instead:","category":"page"},{"location":"quickstart/","page":"Getting Started","title":"Getting Started","text":"# :T is the variable name for temperature, :H represents enthalpy/energy.\n# This is used in the specification of the HeatBalance process type.\n# While this will work with any freeze curve, here we use Westermann (2011) as an example.\nmodel = CryoGrid.Presets.SoilHeatTile(:T, TemperatureGradient(tair), soilprofile, freezecurve=SFCC(Westermann()))","category":"page"},{"location":"api/diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"api/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Modules = [Diagnostics]\nPrivate = false\nOrder = [:type, :function, :macro]","category":"page"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.active_layer_thickness-Tuple{AbstractDimArray{var\"#s280\", N, D, A} where {var\"#s280\"<:(Quantity{T, ùöØ, U} where {T, U<:(Unitful.FreeUnits{N, ùöØ, A} where {N, A})}), N, D<:Tuple, A}}","page":"Diagnostics","title":"CryoGrid.Diagnostics.active_layer_thickness","text":"active_layer_thickness(T::AbstractDimArray{<:TempQuantity})\n\nComputes active layer thickness annually. The active layer thickness is defined here as the maximum thaw depth throughout the calendar year. Assumes T to have dimensions Ti (time) and Z (depth) in any order.\n\n\n\n\n\n","category":"method"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.mean_annual_ground_temperature-Tuple{AbstractDimArray{var\"#s277\", N, D, A} where {var\"#s277\"<:(Quantity{T, ùöØ, U} where {T, U<:(Unitful.FreeUnits{N, ùöØ, A} where {N, A})}), N, D<:Tuple, A}}","page":"Diagnostics","title":"CryoGrid.Diagnostics.mean_annual_ground_temperature","text":"mean_annual_ground_temperature(T::AbstractDimArray; upper_limit=0u\"m\", lower_limit=10u\"m\")\n\nComputes mean annual ground temperature between upper_limit and lower_limit. Assumes T to have dimensions Ti (time) and Z (depth) in any order.\n\n\n\n\n\n","category":"method"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.permafrostbase-Tuple{AbstractDimArray{var\"#s280\", N, D, A} where {var\"#s280\"<:(Quantity{T, ùöØ, U} where {T, U<:(Unitful.FreeUnits{N, ùöØ, A} where {N, A})}), N, D<:Tuple, A}}","page":"Diagnostics","title":"CryoGrid.Diagnostics.permafrostbase","text":"permafrostbase(T::AbstractDimArray{<:TempQuantity})\n\nComputes depth of permafrost base for all years, i.e. the closest depth to the \"bottom\" at which the maximum annual temperature is strictly < 0¬∞C. Assumes T to have dimensions Ti (time) and Z (depth) in any order.\n\n\n\n\n\n","category":"method"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.permafrosttable-Tuple{AbstractDimArray{var\"#s280\", N, D, A} where {var\"#s280\"<:(Quantity{T, ùöØ, U} where {T, U<:(Unitful.FreeUnits{N, ùöØ, A} where {N, A})}), N, D<:Tuple, A}}","page":"Diagnostics","title":"CryoGrid.Diagnostics.permafrosttable","text":"permafrosttable(T::AbstractDimArray{<:TempQuantity})\n\nComputes depth of permafrost table for all years, i.e. the closest depth to the surface at which the maximum annual temperature is strictly < 0¬∞C. Assumes T to have dimensions Ti (time) and Z (depth) in any order.\n\n\n\n\n\n","category":"method"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.spinup-Tuple{Tile, Tuple{DateTime, DateTime}, Any, Any, Any}","page":"Diagnostics","title":"CryoGrid.Diagnostics.spinup","text":"spinup(setup::Tile, tspan::NTuple{2,DateTime}, p, tol, layername; kwargs...)\n\nImplements a simple, iterative spin-up procedure. Runs the model specified by setup over tspan until the profile mean up to maxdepth over the whole time span changes only within the given tolerance tol. Returns the ODESolution generated by the final iteration.\n\n\n\n\n\n","category":"method"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.thawdepth-Tuple{AbstractDimArray{var\"#s280\", N, D, A} where {var\"#s280\"<:(Quantity{T, ùöØ, U} where {T, U<:(Unitful.FreeUnits{N, ùöØ, A} where {N, A})}), N, D<:Tuple, A}}","page":"Diagnostics","title":"CryoGrid.Diagnostics.thawdepth","text":"thawdepth(T::AbstractDimArray{<:TempQuantity})\n\nComputes thaw depth (a.k.a freezing front) at all time steps. Assumes T to have dimensions Ti (time) and Z (depth) in any order.\n\n\n\n\n\n","category":"method"},{"location":"api/diagnostics/#CryoGrid.Diagnostics.zero_annual_amplitude-Tuple{AbstractDimArray{var\"#s277\", N, D, A} where {var\"#s277\"<:(Quantity{T, ùöØ, U} where {T, U<:(Unitful.FreeUnits{N, ùöØ, A} where {N, A})}), N, D<:Tuple, A}}","page":"Diagnostics","title":"CryoGrid.Diagnostics.zero_annual_amplitude","text":"zero_annual_amplitude(T::AbstractDimArray{<:TempQuantity}; threshold=0.5u\"¬∞C\")\n\nComputes annual depth of zero amplitude (where |max - min| < threshold) and returns the result for each year. Assumes T to have dimensions Ti (time) and Z (depth) in any order.\n\n\n\n\n\n","category":"method"},{"location":"#CryoGrid.jl","page":"Home","title":"CryoGrid.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CryoGrid.jl is a Julia implementation of the CryoGrid land surface model using DifferentialEquations.jl and the SciML package ecosystem. Its primary goal is to provide a fast, flexible, and feature rich framework for modeling permafrost in Julia while simultaneously laying the groundwork for rapid prototyping of data-driven parameter estimation, uncertainty quantification, and causal analysis of complex Arctic land surface processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is part of the broader research project: Quantifying and explaining uncertainty in permafrost modeling under a warming climate","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\",\"installation.md\",\"quickstart.md\",\"manual/overview.md\",\"api/index.md\"]","category":"page"}]
}
