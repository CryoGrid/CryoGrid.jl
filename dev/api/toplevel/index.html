<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Method interface · CryoGrid.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CryoGrid.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../quickstart/">Getting Started</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/overview/">Overview</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../">Index</a></li><li class="is-active"><a class="tocitem" href>Method interface</a></li><li><a class="tocitem" href="../numerics/">Numerics</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../heat_conduction/">Heat Conduction</a></li><li><a class="tocitem" href="../hydrology/">Hydrology</a></li><li><a class="tocitem" href="../soils/">Soils</a></li><li><a class="tocitem" href="../snow/">Snow</a></li><li><a class="tocitem" href="../seb/">Surface Energy Balance</a></li></ul></li><li><a class="tocitem" href="../strat/">Stratigraphy</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../presets/">Presets</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Method interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Method interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CryoGrid/CryoGrid.jl/blob/master/docs/src/api/toplevel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="toplevel"><a class="docs-heading-anchor" href="#toplevel">Top level methods and types</a><a id="toplevel-1"></a><a class="docs-heading-anchor-permalink" href="#toplevel" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.Bottom" href="#CryoGrid.Bottom"><code>CryoGrid.Bottom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bottom{TProc&lt;:BoundaryProcesses} &lt;: Layer</code></pre><p>Generic &quot;bottom&quot; layer that marks the lower boundary of the subsurface grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/types.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.BoundaryCondition" href="#CryoGrid.BoundaryCondition"><code>CryoGrid.BoundaryCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition</code></pre><p>Trait that specifies the kind of boundary condition. This can be used to write generic implementations of <code>interact!</code> that are (relatively) agnostic to specific implementations of <code>BoundaryProcess</code>. A good example of this can be found in the <code>boundaryflux</code> method interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/traits.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.BoundaryCondition-Union{Tuple{Type{BP}}, Tuple{BP}} where BP&lt;:BoundaryProcess" href="#CryoGrid.BoundaryCondition-Union{Tuple{Type{BP}}, Tuple{BP}} where BP&lt;:BoundaryProcess"><code>CryoGrid.BoundaryCondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition(::Type{T})</code></pre><p>Can be overriden by <code>BoundaryProcess</code> types to indicate the type of boundary condition, e.g:</p><pre><code class="nohighlight hljs">BoundaryCondition(::Type{BP}) = Dirichlet()</code></pre><p>where <code>BP</code> is a <code>BoundaryProcess</code> that provides the boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/traits.jl#L18-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.BoundaryProcess" href="#CryoGrid.BoundaryProcess"><code>CryoGrid.BoundaryProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryProcess{T&lt;:SubSurfaceProcess}</code></pre><p>Abstract base type for boundary processes, i.e. processes that operate at the boundaries of the subsurface. A <code>BoundaryProcess</code> represents the boundary conditions of one or more <code>SubSurfaceProcess</code>es but may include its own diagnostic (or even prognostic) variables, if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/types.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.ConstantBC" href="#CryoGrid.ConstantBC"><code>CryoGrid.ConstantBC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantBC{P,S,T} &lt;: BoundaryProcess{P}</code></pre><p>Constant boundary condition (of any type/unit) specified by <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/Physics/simple_bc.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.Coupled2" href="#CryoGrid.Coupled2"><code>CryoGrid.Coupled2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coupled2{P1,P2} = CoupledProcesses{Tuple{T1,T2}} where {T1,T2}</code></pre><p>Type alias for coupled processes, i.e. <code>CoupledProcesses{Tuple{P1,P2}}</code>. <code>Coupled</code> provides a simple mechanism for defining new behaviors on multi-processes systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/types.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.CoupledProcesses" href="#CryoGrid.CoupledProcesses"><code>CryoGrid.CoupledProcesses</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoupledProcesses{TProcs} &lt;: Process</code></pre><p>Represents an explicitly or implicitly coupled system of processes. <code>TProcs</code> is always a <code>Tuple</code> of other processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/types.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.CryoGridProblem" href="#CryoGrid.CryoGridProblem"><code>CryoGrid.CryoGridProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CryoGridProblem{iip,Tu,Tt,Tp,TT,Tcb,Tdf,Tkw} &lt;: SciMLBase.AbstractODEProblem{Tu,Tt,iip}</code></pre><p>Represents a CryoGrid discretized PDE forward model configuration using the <code>SciMLBase</code>/<code>DiffEqBase</code> problem interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/problem.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.CryoGridProblem" href="#CryoGrid.CryoGridProblem"><code>CryoGrid.CryoGridProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CryoGridProblem(
    tile::Tile,
    u0::ComponentVector,
    tspan::NTuple{2,Float64},
    p=nothing;
    saveat=3600.0,
    savevars=(),
    save_everystep=false,
    save_start=true,
    save_end=true,
    step_limiter=CryoGrid.timestep,
    safety_factor=1,
    max_step=true,
    callback=nothing,
    isoutofdomain=Strat.domain(tile),
    specialization=SciMLBase.AutoSpecialize,
    function_kwargs=(),
    prob_kwargs...
)</code></pre><p>Constructor for <code>CryoGridProblem</code> that automatically generates necessary callbacks for saving diagnostic state variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/problem.jl#L22-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.CryoGridProblem-Tuple{Tile, ComponentArrays.ComponentVector{T, A, Axes} where {T, A, Axes}, Tuple{DateTime, DateTime}, Vararg{Any, N} where N}" href="#CryoGrid.CryoGridProblem-Tuple{Tile, ComponentArrays.ComponentVector{T, A, Axes} where {T, A, Axes}, Tuple{DateTime, DateTime}, Vararg{Any, N} where N}"><code>CryoGrid.CryoGridProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CryoGridProblem(tile::Tile, u0::ComponentVector, tspan::NTuple{2,DateTime}, args...;kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/problem.jl#L99-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.Layer" href="#CryoGrid.Layer"><code>CryoGrid.Layer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Layer</code></pre><p>Abstract base type for all layers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/types.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.PeriodicBC" href="#CryoGrid.PeriodicBC"><code>CryoGrid.PeriodicBC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PeriodicBC{P,S,T1,T2,T3,T4} &lt;: BoundaryProcess{P}</code></pre><p>Periodic boundary condition (of any type/unit) specified by <code>period</code>, <code>amplitude</code>, and <code>phaseshift</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/Physics/simple_bc.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.Process" href="#CryoGrid.Process"><code>CryoGrid.Process</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for all dynamical processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/types.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.SubSurface" href="#CryoGrid.SubSurface"><code>CryoGrid.SubSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubSurface &lt;: Layer</code></pre><p>Abstract base type for layers in the stratigraphy, e.g. soil, snow, pond, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/types.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.SubSurfaceProcess" href="#CryoGrid.SubSurfaceProcess"><code>CryoGrid.SubSurfaceProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubSurfaceProcess &lt;: Process</code></pre><p>Abstract base type for subsurface processes, i.e. processes that operate at or below the surface, such as heat conduction, water infiltration, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/types.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.Top" href="#CryoGrid.Top"><code>CryoGrid.Top</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Top{TProc&lt;:BoundaryProcesses} &lt;: Layer</code></pre><p>Generic &quot;top&quot; layer that marks the upper boundary of the subsurface grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/types.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.Coupled-Tuple{Vararg{Process, N} where N}" href="#CryoGrid.Coupled-Tuple{Vararg{Process, N} where N}"><code>CryoGrid.Coupled</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Coupled(ps::Process...)</code></pre><p>Constructs a composite/coupled process from one or more processes. Alias for <code>CoupledProcesses(ps...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/types.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.Coupled-Tuple{Vararg{Type{var&quot;#s52&quot;} where var&quot;#s52&quot;&lt;:Process, N} where N}" href="#CryoGrid.Coupled-Tuple{Vararg{Type{var&quot;#s52&quot;} where var&quot;#s52&quot;&lt;:Process, N} where N}"><code>CryoGrid.Coupled</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Coupled(types::Type{&lt;:Process}...)</code></pre><p>Convenince method which constructs a <code>CoupledProcesses</code> type corresponding to each type in <code>types</code>, e.g:</p><pre><code class="nohighlight hljs">Coupled(SnowMassBalance, HeatBalance) = CoupledProcesses{Tuple{T1,T2}} where {T1&lt;:SnowMassBalance, T2&lt;:HeatBalance}</code></pre><p>also equivalent to <code>Coupled2{&lt;:SnowMassBalance,&lt;:HeatBalance}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/types.jl#L58-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.basevariables-Tuple{Layer, Process}" href="#CryoGrid.basevariables-Tuple{Layer, Process}"><code>CryoGrid.basevariables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basevariables(layer::Layer, process::Process)
basevariables(::Layer)
basevariables(::Any)</code></pre><p>Defines &quot;base&quot; or common variables for a given <code>Layer</code>, <code>Process</code>, or arbitrary user-defined type. This should be used to define mandatory or shared variables that should <em>not</em> be overridden by subtypes. As such, <code>basevariables</code> should generally only be defined once per type hierarchy (aside from the default definitions) and only on abstract or union types. Implementations should return a <code>Tuple</code> of <code>Var</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.boundaryflux-Tuple{BoundaryProcess, Union{Bottom, Top}, SubSurfaceProcess, SubSurface, Any, Any}" href="#CryoGrid.boundaryflux-Tuple{BoundaryProcess, Union{Bottom, Top}, SubSurfaceProcess, SubSurface, Any, Any}"><code>CryoGrid.boundaryflux</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryflux(bc::BoundaryProcess, b::Union{Top,Bottom}, p::SubSurfaceProcess, sub::SubSurface, sbc, ssub)
boundaryflux(s::BoundaryCondition, bc::BoundaryProcess, b::Union{Top,Bottom}, p::SubSurfaceProcess, sub::SubSurface, sbc, ssub)</code></pre><p>Computes the flux dH/dt at the boundary layer. Calls boundaryflux(BoundaryCondition(B),...) to allow for generic implementations by boundary condition type. Note that this method uses a different argument order convention than <code>interact!</code>. This is intended to faciliate stratigraphy independent implementations of certain boundary conditions (e.g. a simple Dirichlet boundary could be applied in the same manner to both the upper and lower boundary).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L128-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.boundaryvalue-Tuple{BoundaryProcess, Union{Bottom, Top}, SubSurfaceProcess, SubSurfaceProcess, Any, Any}" href="#CryoGrid.boundaryvalue-Tuple{BoundaryProcess, Union{Bottom, Top}, SubSurfaceProcess, SubSurfaceProcess, Any, Any}"><code>CryoGrid.boundaryvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryvalue(bc::BoundaryProcess, lbc::Union{Top,Bottom}, proc::SubSurfaceProcess, lsub::SubSurfaceProcess, sbc, ssub)</code></pre><p>Computes the value of the boundary condition specified by <code>bc</code> for the given layer/process combinations. Note that this method uses a different argument order convention than <code>interact!</code>. This is intended to faciliate stratigraphy independent implementations of certain boundary conditions (e.g. a simple Dirichlet boundary could be applied in the same manner to both the upper and lower boundary).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.criterion!-Tuple{AbstractArray, GridContinuousEvent, Layer, Any}" href="#CryoGrid.criterion!-Tuple{AbstractArray, GridContinuousEvent, Layer, Any}"><code>CryoGrid.criterion!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">criterion!(out::AbstractArray, ev::GridContinuousEvent, ::Layer, ::Process, state)</code></pre><p>Event criterion for on-grid (i.e. multi-valued) continuous events. The condition for each grid cell should be stored in <code>out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.criterion-Tuple{Union{ContinuousEvent, DiscreteEvent}, Layer, Any}" href="#CryoGrid.criterion-Tuple{Union{ContinuousEvent, DiscreteEvent}, Layer, Any}"><code>CryoGrid.criterion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">criterion(::Event, ::Layer, ::Process, state)</code></pre><p>Event criterion/condition. Should return a <code>Bool</code> for discrete events. For continuous events, this should be a real-valued function where the event is fired at the zeros/roots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L155-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.diagnosticstep!-Tuple{Layer, Any}" href="#CryoGrid.diagnosticstep!-Tuple{Layer, Any}"><code>CryoGrid.diagnosticstep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagnosticstep!(l::Layer, state)
diagnosticstep!(l::Layer, p::Process, state)</code></pre><p>Defines the diagnostic update for a Process on a given Layer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.hasfixedvolume-Tuple{Type{var&quot;#s54&quot;} where var&quot;#s54&quot;&lt;:Layer}" href="#CryoGrid.hasfixedvolume-Tuple{Type{var&quot;#s54&quot;} where var&quot;#s54&quot;&lt;:Layer}"><code>CryoGrid.hasfixedvolume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasfixedvolume(::Type{&lt;:Layer})</code></pre><p>Returns true if the given type has fixed/constant volume or false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/traits.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.initialcondition!-Tuple{Layer, Any}" href="#CryoGrid.initialcondition!-Tuple{Layer, Any}"><code>CryoGrid.initialcondition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialcondition!(::Layer, state)
initialcondition!(::Layer, ::Process, state)
initialcondition!(::Layer, ::Process, state, initializer)</code></pre><p>Defines the initial condition for a given Process and/or Layer. <code>initialcondition!</code> should write initial values into all relevant state variables in <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.initialcondition!-Tuple{Layer, Layer, Any, Any}" href="#CryoGrid.initialcondition!-Tuple{Layer, Layer, Any, Any}"><code>CryoGrid.initialcondition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialcondition!(layer1::Layer, layer2::Layer, state1, state2)
initialcondition!(::Layer, ::Process, ::Layer, ::Process, state1, state2)
initialcondition!(::Layer, ::Process, ::Layer, ::Process, state1, state2, initializer)</code></pre><p>Defines the initial condition for two processes on adjacent layers. <code>initialcondition!</code> should write initial values into all relevant state variables in <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L46-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.initialcondition!-Union{Tuple{P2}, Tuple{P1}, Tuple{Layer, CoupledProcesses{P1}, Layer, CoupledProcesses{P2}, Any, Any}} where {P1, P2}" href="#CryoGrid.initialcondition!-Union{Tuple{P2}, Tuple{P1}, Tuple{Layer, CoupledProcesses{P1}, Layer, CoupledProcesses{P2}, Any, Any}} where {P1, P2}"><code>CryoGrid.initialcondition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialcondition!(l1::Layer, ps1::CoupledProcesses{P1}, l2::Layer, ps2::CoupledProcesses{P2}, s1, s2) where {P1,P2}</code></pre><p>Default implementation of <code>initialcondition!</code> for coupled process types. Calls each process in sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/coupling.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.interact!-Tuple{Layer, Layer, Any, Any}" href="#CryoGrid.interact!-Tuple{Layer, Layer, Any, Any}"><code>CryoGrid.interact!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interact!(::Layer, ::Process, ::Layer, ::Process, state1, state2)</code></pre><p>Defines a boundary interaction between two processes on adjacent layers. For any interaction, the order of the arguments follows decreasing depth, i.e. the first layer/process is always on top of the second layer/process. This ordering matters and separate dispatches must be provided for interactions in reverse order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L76-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.interact!-Union{Tuple{P2}, Tuple{P1}, Tuple{Layer, CoupledProcesses{P1}, Layer, CoupledProcesses{P2}, Any, Any}} where {P1, P2}" href="#CryoGrid.interact!-Union{Tuple{P2}, Tuple{P1}, Tuple{Layer, CoupledProcesses{P1}, Layer, CoupledProcesses{P2}, Any, Any}} where {P1, P2}"><code>CryoGrid.interact!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interact!(l1::Layer, ps1::CoupledProcesses{P1}, l2::Layer, ps2::CoupledProcesses{P2}, s1, s2) where {P1,P2}</code></pre><p>Default implementation of <code>interact!</code> for coupled process (CoupledProcesses) types. Generates a specialized implementation that calls <code>interact!</code> on all pairs of processes between the two layers. Since it is a generated function, the process matching occurs at compile-time and the emitted code will simply be a sequence of <code>interact!</code> calls. Pairs of processes which lack a definition of <code>interact!</code> will be automatically omitted by the compiler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/coupling.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.processes-Tuple{Layer}" href="#CryoGrid.processes-Tuple{Layer}"><code>CryoGrid.processes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">processes(l::Layer)</code></pre><p>Fetches the process(es) attached to this layer, if any. Returned value must be of type <code>Process</code>. If the layer has more than one process, they should be combined together with <code>Coupled(procs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.prognosticstep!-Tuple{Layer, Any}" href="#CryoGrid.prognosticstep!-Tuple{Layer, Any}"><code>CryoGrid.prognosticstep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prognosticstep!(l::Layer, p::Process, state)</code></pre><p>Defines the prognostic update for a Process on a given layer. Note that an instance of <code>prognosticstep!</code> must be provided for all non-boundary (subsurface) processes/layers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.timestep-Tuple{Layer, Any}" href="#CryoGrid.timestep-Tuple{Layer, Any}"><code>CryoGrid.timestep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">timestep(::Layer, ::Process, state)</code></pre><p>Retrieves the recommended timestep for the given <code>Process</code> defined on the given <code>Layer</code>. The default implementation returns <code>Inf</code> which indicates no timestep restriction. The actual chosen timestep will depend on the integrator being used and other user configuration options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.timestep-Union{Tuple{P}, Tuple{Layer, CoupledProcesses{P}, Any}} where P" href="#CryoGrid.timestep-Union{Tuple{P}, Tuple{Layer, CoupledProcesses{P}, Any}} where P"><code>CryoGrid.timestep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">timestep(l::Layer, ps::CoupledProcesses{P}, state) where {P}</code></pre><p>Default implementation of <code>timestep</code> for coupled process types. Calls each process in sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/coupling.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.trigger!-Tuple{CryoGrid.Event, Layer, Any}" href="#CryoGrid.trigger!-Tuple{CryoGrid.Event, Layer, Any}"><code>CryoGrid.trigger!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trigger!(::Event, ::Layer, ::Process, state)
trigger!(ev::ContinuousEvent, ::ContinuousTrigger, ::Layer, ::Process, state)
trigger!(ev::GridContinuousEvent, ::ContinuousTrigger, ::Layer, ::Process, state)</code></pre><p>Event action executed when <code>criterion</code> is met.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L172-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.variables-Tuple{Layer, Process}" href="#CryoGrid.variables-Tuple{Layer, Process}"><code>CryoGrid.variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variables(layer::Layer, process::Process)
variables(::Layer)
variables(::Any)</code></pre><p>Defines variables for a given <code>Layer</code>, <code>Process</code>, or arbitrary user-defined type. Implementations should return a <code>Tuple</code> of <code>Var</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/methods.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryoGrid.volumetricfractions-Tuple{SubSurface, Any}" href="#CryoGrid.volumetricfractions-Tuple{SubSurface, Any}"><code>CryoGrid.volumetricfractions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">volumetricfractions(::SubSurface, state)
volumetricfractions(::SubSurface, state, i)</code></pre><p>Get the volumetric fractions of each constituent in the volume (at grid cell <code>i</code>, if specificed). All implementations of <code>volumetricfractions</code> are expected to obey a semi-consistent order in the returned <code>Tuple</code> of fractions; the first three consituents should always be <code>θw,θi,θa</code>, i.e. water, ice, and air, followed by any number of additional constituents which may be defined by the specific layer. There is no feasible way to verify that client code actually obeys this ordering, so be sure to double check your implementation, otherwise this can cause very subtle bugs!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CryoGrid/CryoGrid.jl/blob/13e85ac16129b8e54c247064240cecbfd7999f34/src/Physics/Physics.jl#L13-L23">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Index</a><a class="docs-footer-nextpage" href="../numerics/">Numerics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 24 March 2023 12:05">Friday 24 March 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
